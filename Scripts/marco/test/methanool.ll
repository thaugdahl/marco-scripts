@var_name_16 = internal constant [8 x i8] c"der_T_w\00"
@var_name_15 = internal constant [12 x i8] c"der_T_tilde\00"
@var_name_14 = internal constant [8 x i8] c"der_T_m\00"
@var_name_13 = internal constant [4 x i8] c"T_m\00"
@var_name_12 = internal constant [4 x i8] c"T_w\00"
@var_name_11 = internal constant [5 x i8] c"cv_m\00"
@var_name_10 = internal constant [3 x i8] c"cv\00"
@var_name_9 = internal constant [6 x i8] c"rho_m\00"
@var_name_8 = internal constant [4 x i8] c"rho\00"
@var_name_7 = internal constant [8 x i8] c"T_tilde\00"
@var_name_6 = internal constant [4 x i8] c"h_m\00"
@var_name_5 = internal constant [2 x i8] c"h\00"
@var_name_4 = internal constant [2 x i8] c"T\00"
@var_name_3 = internal constant [4 x i8] c"Q_c\00"
@var_name_2 = internal constant [2 x i8] c"Q\00"
@var_name_1 = internal constant [4 x i8] c"w_h\00"
@var_name_0 = internal constant [2 x i8] c"w\00"
@var_name_unknown = internal constant [1 x i8] zeroinitializer
@modelName = internal constant [23 x i8] c"MethanolHeatExchangers\00"
@__constant_8xf64_0 = private unnamed_addr constant [8 x double] [double 0x400F34F61672324C, double 1.099290e+01, double 1.833710e+01, double -1.636630e+01, double -6.223340e+00, double 2.803580e+00, double 1.077830e+00, double 9.696700e-01], align 64
@time = private unnamed_addr global double undef
@var = private unnamed_addr global double undef
@var_0 = private unnamed_addr global double undef
@var_1 = private unnamed_addr global [4 x double] undef
@var_2 = private unnamed_addr global [3 x [4 x [6 x double]]] undef, align 128
@var_3 = private unnamed_addr global [3 x [4 x [7 x double]]] undef
@var_4 = private unnamed_addr global [3 x [4 x [7 x double]]] undef
@var_5 = private unnamed_addr global [3 x double] undef
@var_6 = private unnamed_addr global [3 x [4 x [6 x double]]] undef, align 128
@var_7 = private unnamed_addr global [3 x [4 x [6 x double]]] undef, align 128
@var_8 = private unnamed_addr global [3 x double] undef
@var_9 = private unnamed_addr global [3 x [4 x [6 x double]]] undef
@var_10 = private unnamed_addr global [3 x double] undef
@var_11 = private unnamed_addr global [3 x [4 x [6 x double]]] undef, align 128
@var_12 = private unnamed_addr global [3 x double] undef
@var_13 = private unnamed_addr global [3 x double] undef
@var_14 = private unnamed_addr global [3 x [4 x [6 x double]]] undef
@var_15 = private unnamed_addr global [3 x [4 x [6 x double]]] undef
@timeStep = private unnamed_addr global double undef
@switch.table.getVariableName.rel = private unnamed_addr constant [17 x i32] [i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_0 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_1 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_2 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_3 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_4 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_5 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_6 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_7 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_8 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_9 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_10 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_11 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_12 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_13 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_14 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_15 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32), i32 trunc (i64 sub (i64 ptrtoint (ptr @var_name_16 to i64), i64 ptrtoint (ptr @switch.table.getVariableName.rel to i64)) to i32)], align 4
@switch.table.getVariableRank = private unnamed_addr constant [15 x i64] [i64 1, i64 3, i64 3, i64 3, i64 1, i64 3, i64 3, i64 1, i64 3, i64 1, i64 3, i64 1, i64 1, i64 3, i64 3], align 8
@switch.table.getDerivative = private unnamed_addr constant [7 x i64] [i64 15, i64 -1, i64 -1, i64 -1, i64 -1, i64 16, i64 14], align 8

declare double @_Msin_f64_f64(double) local_unnamed_addr

declare double @_Mexp_f64_f64(double) local_unnamed_addr

declare double @_Mpow_f64_f64_f64(double, double) local_unnamed_addr

define double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %0) local_unnamed_addr {
  %2 = fdiv double 5.126400e+02, %0
  %3 = alloca [8 x double], align 64
  %4 = getelementptr inbounds nuw i8, ptr %3, i64 8
  %5 = insertelement <2 x double> poison, double %2, i64 0
  %6 = shufflevector <2 x double> %5, <2 x double> poison, <2 x i32> zeroinitializer
  %7 = fmul <2 x double> %6, <double 4.125750e+00, double 3.269730e+00>
  store <2 x double> %7, ptr %4, align 8
  %8 = getelementptr inbounds nuw i8, ptr %3, i64 24
  %9 = fmul <2 x double> %6, <double 3.774920e+00, double 2.935740e+00>
  store <2 x double> %9, ptr %8, align 8
  %10 = getelementptr inbounds nuw i8, ptr %3, i64 40
  %11 = fmul <2 x double> %6, <double 8.237470e+00, double 1.033120e+01>
  store <2 x double> %11, ptr %10, align 8
  %12 = fmul double %2, 5.332600e-01
  %13 = getelementptr inbounds nuw i8, ptr %3, i64 56
  store double %12, ptr %13, align 8
  br label %thread-pre-split

thread-pre-split:                                 ; preds = %thread-pre-split, %1
  %14 = phi i64 [ 2, %1 ], [ %31, %thread-pre-split ]
  %.06 = phi double [ 0x400F34F61672324C, %1 ], [ %30, %thread-pre-split ]
  %15 = phi i64 [ 1, %1 ], [ %14, %thread-pre-split ]
  %16 = getelementptr inbounds nuw double, ptr @__constant_8xf64_0, i64 %15
  %17 = load double, ptr %16, align 8
  %18 = getelementptr inbounds nuw double, ptr %3, i64 %15
  %19 = load double, ptr %18, align 8
  %20 = tail call ptr @llvm.stacksave.p0()
  %21 = tail call double @_Mpow_f64_f64_f64(double %19, double 2.000000e+00)
  call void @llvm.stackrestore.p0(ptr %20)
  %22 = fmul double %17, %21
  %23 = tail call ptr @llvm.stacksave.p0()
  %24 = tail call double @_Mexp_f64_f64(double %19)
  call void @llvm.stackrestore.p0(ptr %23)
  %25 = fmul double %22, %24
  %26 = fadd double %24, -1.000000e+00
  %27 = tail call ptr @llvm.stacksave.p0()
  %28 = tail call double @_Mpow_f64_f64_f64(double %26, double 2.000000e+00)
  call void @llvm.stackrestore.p0(ptr %27)
  %29 = fdiv double %25, %28
  %30 = fadd double %.06, %29
  %31 = add nuw nsw i64 %14, 1
  %32 = icmp samesign ult i64 %14, 8
  br i1 %32, label %thread-pre-split, label %33

33:                                               ; preds = %thread-pre-split
  %34 = fmul double %30, 0x4070380A7B9F18DE
  ret double %34
}

define double @_MMethanolHeatExchangersDAE.Models.Methanol.cv_T(double %0) local_unnamed_addr {
  %2 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %0)
  %3 = fadd double %2, 0xC070380A7B9F18DE
  ret double %3
}

define double @_MMethanolHeatExchangersDAE.Models.Methanol.h_T(double %0) local_unnamed_addr {
thread-pre-split:
  %1 = fdiv double 5.126400e+02, %0
  %2 = fdiv double 0x400F34F61672324C, %1
  %3 = fmul double %1, 5.332600e-01
  %4 = insertelement <2 x double> poison, double %1, i64 0
  %5 = shufflevector <2 x double> %4, <2 x double> poison, <2 x i32> zeroinitializer
  %6 = fmul <2 x double> %5, <double 8.237470e+00, double 1.033120e+01>
  %7 = fmul <2 x double> %5, <double 3.774920e+00, double 2.935740e+00>
  %8 = fmul <2 x double> %5, <double 4.125750e+00, double 3.269730e+00>
  %.sroa.0.8.vec.extract = extractelement <2 x double> %8, i64 0
  %9 = tail call ptr @llvm.stacksave.p0()
  %10 = tail call double @_Mexp_f64_f64(double %.sroa.0.8.vec.extract)
  call void @llvm.stackrestore.p0(ptr %9)
  %11 = fadd double %10, -1.000000e+00
  %12 = fdiv double 0x4046AD4E77FD67A0, %11
  %13 = fadd double %2, %12
  %.sroa.0.16.vec.extract = extractelement <2 x double> %8, i64 1
  %14 = tail call ptr @llvm.stacksave.p0()
  %15 = tail call double @_Mexp_f64_f64(double %.sroa.0.16.vec.extract)
  call void @llvm.stackrestore.p0(ptr %14)
  %16 = fadd double %15, -1.000000e+00
  %17 = fdiv double 0x404DFA8AF7F1A4D9, %16
  %18 = fadd double %13, %17
  %.sroa.3.24.vec.extract = extractelement <2 x double> %7, i64 0
  %19 = tail call ptr @llvm.stacksave.p0()
  %20 = tail call double @_Mexp_f64_f64(double %.sroa.3.24.vec.extract)
  call void @llvm.stackrestore.p0(ptr %19)
  %21 = fadd double %20, -1.000000e+00
  %22 = fdiv double 0xC04EE407504DC2A2, %21
  %23 = fadd double %18, %22
  %.sroa.3.32.vec.extract = extractelement <2 x double> %7, i64 1
  %24 = tail call ptr @llvm.stacksave.p0()
  %25 = tail call double @_Mexp_f64_f64(double %.sroa.3.32.vec.extract)
  call void @llvm.stackrestore.p0(ptr %24)
  %26 = fadd double %25, -1.000000e+00
  %27 = fdiv double 0xC0324525CF236784, %26
  %28 = fadd double %23, %27
  %.sroa.6.40.vec.extract = extractelement <2 x double> %6, i64 0
  %29 = tail call ptr @llvm.stacksave.p0()
  %30 = tail call double @_Mexp_f64_f64(double %.sroa.6.40.vec.extract)
  call void @llvm.stackrestore.p0(ptr %29)
  %31 = fadd double %30, -1.000000e+00
  %32 = fdiv double 0x4037182B003F022E, %31
  %33 = fadd double %28, %32
  %.sroa.6.48.vec.extract = extractelement <2 x double> %6, i64 1
  %34 = tail call ptr @llvm.stacksave.p0()
  %35 = tail call double @_Mexp_f64_f64(double %.sroa.6.48.vec.extract)
  call void @llvm.stackrestore.p0(ptr %34)
  %36 = fadd double %35, -1.000000e+00
  %37 = fdiv double 0x4026454310D46C32, %36
  %38 = fadd double %33, %37
  %39 = tail call double @_Mexp_f64_f64(double %3)
  %40 = fadd double %39, -1.000000e+00
  %41 = fdiv double 0x3FE08BF868C4D601, %40
  %42 = fadd double %38, %41
  %43 = fmul double %0, 0x4070380A7B9F18DE
  %44 = fmul double %43, %1
  %45 = fmul double %44, %42
  %46 = fmul double %1, 1.361810e+03
  %47 = fdiv double %46, 5.126400e+02
  %48 = fsub double %45, %47
  ret double %48
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @euler_state_update_T_tilde(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr #0 {
  %7 = load double, ptr @timeStep, align 8
  %8 = icmp slt i64 %0, %1
  br i1 %8, label %.preheader1.lr.ph, label %._crit_edge3

.preheader1.lr.ph:                                ; preds = %6
  %9 = icmp slt i64 %2, %3
  %10 = icmp slt i64 %4, %5
  %11 = sub i64 %5, %4
  %min.iters.check = icmp ult i64 %11, 4
  %n.vec = and i64 %11, -4
  %12 = add i64 %4, %n.vec
  %broadcast.splatinsert = insertelement <2 x double> poison, double %7, i64 0
  %broadcast.splat = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <2 x i32> zeroinitializer
  %cmp.n = icmp eq i64 %11, %n.vec
  br label %.preheader1

.preheader1:                                      ; preds = %._crit_edge2, %.preheader1.lr.ph
  %13 = phi i64 [ %0, %.preheader1.lr.ph ], [ %37, %._crit_edge2 ]
  br i1 %9, label %.preheader.lr.ph, label %._crit_edge2

.preheader.lr.ph:                                 ; preds = %.preheader1
  %14 = mul nuw nsw i64 %13, 24
  br label %.preheader

.preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
  %15 = phi i64 [ %2, %.preheader.lr.ph ], [ %36, %._crit_edge ]
  br i1 %10, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %.preheader
  %16 = mul nuw nsw i64 %15, 6
  %17 = add nuw nsw i64 %16, %14
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %invariant.op = add i64 %4, %17
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %.reass = add i64 %index, %invariant.op
  %18 = getelementptr inbounds nuw double, ptr @var_6, i64 %.reass
  %19 = getelementptr inbounds nuw i8, ptr %18, i64 16
  %wide.load = load <2 x double>, ptr %18, align 8
  %wide.load15 = load <2 x double>, ptr %19, align 8
  %20 = getelementptr inbounds nuw double, ptr @var_14, i64 %.reass
  %21 = getelementptr inbounds nuw i8, ptr %20, i64 16
  %wide.load16 = load <2 x double>, ptr %20, align 8
  %wide.load17 = load <2 x double>, ptr %21, align 8
  %22 = fmul <2 x double> %broadcast.splat, %wide.load16
  %23 = fmul <2 x double> %broadcast.splat, %wide.load17
  %24 = fadd <2 x double> %wide.load, %22
  %25 = fadd <2 x double> %wide.load15, %23
  store <2 x double> %24, ptr %18, align 8
  store <2 x double> %25, ptr %19, align 8
  %index.next = add nuw i64 %index, 4
  %26 = icmp eq i64 %index.next, %n.vec
  br i1 %26, label %middle.block, label %vector.body, !llvm.loop !1

middle.block:                                     ; preds = %vector.body
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %.lr.ph, %middle.block
  %.ph = phi i64 [ %4, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %27 = phi i64 [ %35, %scalar.ph ], [ %.ph, %scalar.ph.preheader ]
  %28 = add nuw nsw i64 %17, %27
  %29 = getelementptr inbounds nuw double, ptr @var_6, i64 %28
  %30 = load double, ptr %29, align 8
  %31 = getelementptr inbounds nuw double, ptr @var_14, i64 %28
  %32 = load double, ptr %31, align 8
  %33 = fmul double %7, %32
  %34 = fadd double %30, %33
  store double %34, ptr %29, align 8
  %35 = add nsw i64 %27, 1
  %exitcond.not = icmp eq i64 %35, %5
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !4

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %.preheader
  %36 = add nsw i64 %15, 1
  %exitcond4.not = icmp eq i64 %36, %3
  br i1 %exitcond4.not, label %._crit_edge2, label %.preheader

._crit_edge2:                                     ; preds = %._crit_edge, %.preheader1
  %37 = add nsw i64 %13, 1
  %exitcond5.not = icmp eq i64 %37, %1
  br i1 %exitcond5.not, label %._crit_edge3, label %.preheader1

._crit_edge3:                                     ; preds = %._crit_edge2, %6
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @euler_state_update_T_w(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr #0 {
  %7 = load double, ptr @timeStep, align 8
  %8 = icmp slt i64 %0, %1
  br i1 %8, label %.preheader1.lr.ph, label %._crit_edge3

.preheader1.lr.ph:                                ; preds = %6
  %9 = icmp slt i64 %2, %3
  %10 = icmp slt i64 %4, %5
  %11 = sub i64 %5, %4
  %min.iters.check = icmp ult i64 %11, 4
  %n.vec = and i64 %11, -4
  %12 = add i64 %4, %n.vec
  %broadcast.splatinsert = insertelement <2 x double> poison, double %7, i64 0
  %broadcast.splat = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <2 x i32> zeroinitializer
  %cmp.n = icmp eq i64 %11, %n.vec
  br label %.preheader1

.preheader1:                                      ; preds = %._crit_edge2, %.preheader1.lr.ph
  %13 = phi i64 [ %0, %.preheader1.lr.ph ], [ %37, %._crit_edge2 ]
  br i1 %9, label %.preheader.lr.ph, label %._crit_edge2

.preheader.lr.ph:                                 ; preds = %.preheader1
  %14 = mul nuw nsw i64 %13, 24
  br label %.preheader

.preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
  %15 = phi i64 [ %2, %.preheader.lr.ph ], [ %36, %._crit_edge ]
  br i1 %10, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %.preheader
  %16 = mul nuw nsw i64 %15, 6
  %17 = add nuw nsw i64 %16, %14
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %invariant.op = add i64 %4, %17
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %.reass = add i64 %index, %invariant.op
  %18 = getelementptr inbounds nuw double, ptr @var_11, i64 %.reass
  %19 = getelementptr inbounds nuw i8, ptr %18, i64 16
  %wide.load = load <2 x double>, ptr %18, align 8
  %wide.load15 = load <2 x double>, ptr %19, align 8
  %20 = getelementptr inbounds nuw double, ptr @var_15, i64 %.reass
  %21 = getelementptr inbounds nuw i8, ptr %20, i64 16
  %wide.load16 = load <2 x double>, ptr %20, align 8
  %wide.load17 = load <2 x double>, ptr %21, align 8
  %22 = fmul <2 x double> %broadcast.splat, %wide.load16
  %23 = fmul <2 x double> %broadcast.splat, %wide.load17
  %24 = fadd <2 x double> %wide.load, %22
  %25 = fadd <2 x double> %wide.load15, %23
  store <2 x double> %24, ptr %18, align 8
  store <2 x double> %25, ptr %19, align 8
  %index.next = add nuw i64 %index, 4
  %26 = icmp eq i64 %index.next, %n.vec
  br i1 %26, label %middle.block, label %vector.body, !llvm.loop !5

middle.block:                                     ; preds = %vector.body
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %.lr.ph, %middle.block
  %.ph = phi i64 [ %4, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %27 = phi i64 [ %35, %scalar.ph ], [ %.ph, %scalar.ph.preheader ]
  %28 = add nuw nsw i64 %17, %27
  %29 = getelementptr inbounds nuw double, ptr @var_11, i64 %28
  %30 = load double, ptr %29, align 8
  %31 = getelementptr inbounds nuw double, ptr @var_15, i64 %28
  %32 = load double, ptr %31, align 8
  %33 = fmul double %7, %32
  %34 = fadd double %30, %33
  store double %34, ptr %29, align 8
  %35 = add nsw i64 %27, 1
  %exitcond.not = icmp eq i64 %35, %5
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !6

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %.preheader
  %36 = add nsw i64 %15, 1
  %exitcond4.not = icmp eq i64 %36, %3
  br i1 %exitcond4.not, label %._crit_edge2, label %.preheader

._crit_edge2:                                     ; preds = %._crit_edge, %.preheader1
  %37 = add nsw i64 %13, 1
  %exitcond5.not = icmp eq i64 %37, %1
  br i1 %exitcond5.not, label %._crit_edge3, label %.preheader1

._crit_edge3:                                     ; preds = %._crit_edge2, %6
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @euler_state_update_T_m(i64 %0, i64 %1) local_unnamed_addr #0 {
  %3 = load double, ptr @timeStep, align 8
  %4 = icmp slt i64 %0, %1
  br i1 %4, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %2
  %5 = sub i64 %1, %0
  %min.iters.check = icmp ult i64 %5, 4
  br i1 %min.iters.check, label %.lr.ph.preheader5, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph.preheader
  %n.vec = and i64 %5, -4
  %6 = add i64 %0, %n.vec
  %broadcast.splatinsert = insertelement <2 x double> poison, double %3, i64 0
  %broadcast.splat = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <2 x i32> zeroinitializer
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %offset.idx = add i64 %0, %index
  %7 = getelementptr inbounds nuw double, ptr @var_12, i64 %offset.idx
  %8 = getelementptr inbounds nuw i8, ptr %7, i64 16
  %wide.load = load <2 x double>, ptr %7, align 8
  %wide.load2 = load <2 x double>, ptr %8, align 8
  %9 = getelementptr inbounds nuw double, ptr @var_13, i64 %offset.idx
  %10 = getelementptr inbounds nuw i8, ptr %9, i64 16
  %wide.load3 = load <2 x double>, ptr %9, align 8
  %wide.load4 = load <2 x double>, ptr %10, align 8
  %11 = fmul <2 x double> %broadcast.splat, %wide.load3
  %12 = fmul <2 x double> %broadcast.splat, %wide.load4
  %13 = fadd <2 x double> %wide.load, %11
  %14 = fadd <2 x double> %wide.load2, %12
  store <2 x double> %13, ptr %7, align 8
  store <2 x double> %14, ptr %8, align 8
  %index.next = add nuw i64 %index, 4
  %15 = icmp eq i64 %index.next, %n.vec
  br i1 %15, label %middle.block, label %vector.body, !llvm.loop !7

middle.block:                                     ; preds = %vector.body
  %cmp.n = icmp eq i64 %5, %n.vec
  br i1 %cmp.n, label %._crit_edge, label %.lr.ph.preheader5

.lr.ph.preheader5:                                ; preds = %.lr.ph.preheader, %middle.block
  %.ph = phi i64 [ %0, %.lr.ph.preheader ], [ %6, %middle.block ]
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader5, %.lr.ph
  %16 = phi i64 [ %23, %.lr.ph ], [ %.ph, %.lr.ph.preheader5 ]
  %17 = getelementptr inbounds nuw double, ptr @var_12, i64 %16
  %18 = load double, ptr %17, align 8
  %19 = getelementptr inbounds nuw double, ptr @var_13, i64 %16
  %20 = load double, ptr %19, align 8
  %21 = fmul double %3, %20
  %22 = fadd double %18, %21
  store double %22, ptr %17, align 8
  %23 = add nsw i64 %16, 1
  %exitcond.not = icmp eq i64 %23, %1
  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph, !llvm.loop !8

._crit_edge:                                      ; preds = %.lr.ph, %middle.block, %2
  ret void
}

define void @equation() local_unnamed_addr {
  %1 = load double, ptr @time, align 8
  %2 = fmul double %1, 0x3FCACEE9F37BEDC6
  %3 = tail call double @_Msin_f64_f64(double %2)
  %4 = fmul double %3, 2.000000e-01
  %5 = fadd double %4, 1.000000e+00
  store double %5, ptr @var, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_0() local_unnamed_addr #1 {
  %1 = load double, ptr @var, align 8
  %2 = fmul double %1, 2.500000e-01
  store double %2, ptr @var_0, align 8
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_1(i64 %0, i64 %1) local_unnamed_addr #0 {
  %3 = icmp slt i64 %0, %1
  br i1 %3, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %2
  %4 = sub i64 %1, %0
  %min.iters.check = icmp ult i64 %4, 2
  br i1 %min.iters.check, label %.lr.ph.preheader2, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph.preheader
  %n.vec = and i64 %4, -2
  %5 = add i64 %0, %n.vec
  %invariant.op = add i64 %0, -1
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %.reass = add i64 %index, %invariant.op
  %6 = getelementptr inbounds nuw double, ptr @var_12, i64 %.reass
  %wide.load = load <2 x double>, ptr %6, align 8
  %7 = fmul <2 x double> %wide.load, splat (double 0x4070380A7B9F18DE)
  %8 = fdiv <2 x double> splat (double 2.000000e+06), %7
  %9 = getelementptr double, ptr @var_8, i64 %.reass
  store <2 x double> %8, ptr %9, align 8
  %index.next = add nuw i64 %index, 2
  %10 = icmp eq i64 %index.next, %n.vec
  br i1 %10, label %middle.block, label %vector.body, !llvm.loop !9

middle.block:                                     ; preds = %vector.body
  %cmp.n = icmp eq i64 %4, %n.vec
  br i1 %cmp.n, label %._crit_edge, label %.lr.ph.preheader2

.lr.ph.preheader2:                                ; preds = %.lr.ph.preheader, %middle.block
  %.ph = phi i64 [ %0, %.lr.ph.preheader ], [ %5, %middle.block ]
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader2, %.lr.ph
  %11 = phi i64 [ %18, %.lr.ph ], [ %.ph, %.lr.ph.preheader2 ]
  %12 = add i64 %11, -1
  %13 = getelementptr inbounds nuw double, ptr @var_12, i64 %12
  %14 = load double, ptr %13, align 8
  %15 = fmul double %14, 0x4070380A7B9F18DE
  %16 = fdiv double 2.000000e+06, %15
  %17 = getelementptr double, ptr @var_8, i64 %12
  store double %16, ptr %17, align 8
  %18 = add nsw i64 %11, 1
  %exitcond.not = icmp eq i64 %18, %1
  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph, !llvm.loop !10

._crit_edge:                                      ; preds = %.lr.ph, %middle.block, %2
  ret void
}

define void @equation_2(i64 %0, i64 %1) local_unnamed_addr {
  %3 = icmp slt i64 %0, %1
  br i1 %3, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %2, %.lr.ph
  %4 = phi i64 [ %54, %.lr.ph ], [ %0, %2 ]
  %5 = add i64 %4, -1
  %6 = getelementptr inbounds nuw double, ptr @var_12, i64 %5
  %7 = load double, ptr %6, align 8
  %8 = tail call ptr @llvm.stacksave.p0()
  %9 = fdiv double 5.126400e+02, %7
  %10 = fmul double %9, 4.125750e+00
  %11 = fmul double %9, 3.269730e+00
  %12 = fmul double %9, 3.774920e+00
  %13 = fmul double %9, 2.935740e+00
  %14 = fmul double %9, 8.237470e+00
  %15 = fmul double %9, 1.033120e+01
  %16 = fmul double %9, 5.332600e-01
  %17 = tail call double @_Mexp_f64_f64(double %10)
  call void @llvm.stackrestore.p0(ptr %8)
  %18 = fadd double %17, -1.000000e+00
  %19 = insertelement <2 x double> poison, double %9, i64 0
  %20 = insertelement <2 x double> %19, double %18, i64 1
  %21 = fdiv <2 x double> <double 0x400F34F61672324C, double 0x4046AD4E77FD67A0>, %20
  %shift = shufflevector <2 x double> %21, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop = fadd <2 x double> %21, %shift
  %22 = tail call ptr @llvm.stacksave.p0()
  %23 = tail call double @_Mexp_f64_f64(double %11)
  call void @llvm.stackrestore.p0(ptr %22)
  %24 = tail call ptr @llvm.stacksave.p0()
  %25 = tail call double @_Mexp_f64_f64(double %12)
  call void @llvm.stackrestore.p0(ptr %24)
  %26 = insertelement <2 x double> poison, double %23, i64 0
  %27 = insertelement <2 x double> %26, double %25, i64 1
  %28 = fadd <2 x double> %27, splat (double -1.000000e+00)
  %29 = fdiv <2 x double> <double 0x404DFA8AF7F1A4D9, double 0xC04EE407504DC2A2>, %28
  %foldExtExtBinop3 = fadd <2 x double> %foldExtExtBinop, %29
  %shift5 = shufflevector <2 x double> %29, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop6 = fadd <2 x double> %foldExtExtBinop3, %shift5
  %30 = tail call ptr @llvm.stacksave.p0()
  %31 = tail call double @_Mexp_f64_f64(double %13)
  call void @llvm.stackrestore.p0(ptr %30)
  %32 = tail call ptr @llvm.stacksave.p0()
  %33 = tail call double @_Mexp_f64_f64(double %14)
  call void @llvm.stackrestore.p0(ptr %32)
  %34 = insertelement <2 x double> poison, double %31, i64 0
  %35 = insertelement <2 x double> %34, double %33, i64 1
  %36 = fadd <2 x double> %35, splat (double -1.000000e+00)
  %37 = fdiv <2 x double> <double 0xC0324525CF236784, double 0x4037182B003F022E>, %36
  %foldExtExtBinop8 = fadd <2 x double> %foldExtExtBinop6, %37
  %shift10 = shufflevector <2 x double> %37, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop11 = fadd <2 x double> %foldExtExtBinop8, %shift10
  %38 = tail call ptr @llvm.stacksave.p0()
  %39 = tail call double @_Mexp_f64_f64(double %15)
  call void @llvm.stackrestore.p0(ptr %38)
  %40 = tail call ptr @llvm.stacksave.p0()
  %41 = tail call double @_Mexp_f64_f64(double %16)
  call void @llvm.stackrestore.p0(ptr %40)
  %42 = insertelement <2 x double> poison, double %39, i64 0
  %43 = insertelement <2 x double> %42, double %41, i64 1
  %44 = fadd <2 x double> %43, splat (double -1.000000e+00)
  %45 = fdiv <2 x double> <double 0x4026454310D46C32, double 0x3FE08BF868C4D601>, %44
  %foldExtExtBinop13 = fadd <2 x double> %foldExtExtBinop11, %45
  %shift15 = shufflevector <2 x double> %45, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop16 = fadd <2 x double> %foldExtExtBinop13, %shift15
  %46 = extractelement <2 x double> %foldExtExtBinop16, i64 0
  %47 = fmul double %7, 0x4070380A7B9F18DE
  %48 = fmul double %47, %9
  %49 = fmul double %48, %46
  %50 = fmul double %9, 1.361810e+03
  %51 = fdiv double %50, 5.126400e+02
  %52 = fsub double %49, %51
  %53 = getelementptr double, ptr @var_5, i64 %5
  store double %52, ptr %53, align 8
  %54 = add i64 %4, 1
  %exitcond.not = icmp eq i64 %54, %1
  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %2
  ret void
}

define void @equation_3(i64 %0, i64 %1) local_unnamed_addr {
  %3 = icmp slt i64 %0, %1
  br i1 %3, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %2, %.lr.ph
  %4 = phi i64 [ %11, %.lr.ph ], [ %0, %2 ]
  %5 = add i64 %4, -1
  %6 = getelementptr inbounds nuw double, ptr @var_12, i64 %5
  %7 = load double, ptr %6, align 8
  %8 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %7)
  %9 = fadd double %8, 0xC070380A7B9F18DE
  %10 = getelementptr double, ptr @var_10, i64 %5
  store double %9, ptr %10, align 8
  %11 = add i64 %4, 1
  %exitcond.not = icmp eq i64 %11, %1
  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %2
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_4(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr #0 {
  %7 = icmp slt i64 %0, %1
  br i1 %7, label %.preheader3.lr.ph, label %._crit_edge5

.preheader3.lr.ph:                                ; preds = %6
  %8 = icmp slt i64 %2, %3
  %9 = icmp slt i64 %4, %5
  %10 = sub i64 %5, %4
  %min.iters.check = icmp ult i64 %10, 2
  %n.vec = and i64 %10, -2
  %11 = add i64 %4, %n.vec
  %cmp.n = icmp eq i64 %10, %n.vec
  br label %.preheader3

.preheader3:                                      ; preds = %._crit_edge4, %.preheader3.lr.ph
  %12 = phi i64 [ %0, %.preheader3.lr.ph ], [ %32, %._crit_edge4 ]
  br i1 %8, label %.preheader.lr.ph, label %._crit_edge4

.preheader.lr.ph:                                 ; preds = %.preheader3
  %13 = mul i64 %12, 24
  %14 = add i64 %13, -31
  br label %.preheader

.preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
  %15 = phi i64 [ %2, %.preheader.lr.ph ], [ %31, %._crit_edge ]
  br i1 %9, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %.preheader
  %16 = mul i64 %15, 6
  %17 = add i64 %14, %16
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %invariant.op = add i64 %4, %17
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %.reass = add i64 %index, %invariant.op
  %18 = getelementptr inbounds nuw double, ptr @var_6, i64 %.reass
  %wide.load = load <2 x double>, ptr %18, align 8
  %19 = fmul <2 x double> %wide.load, splat (double 0x4070380A7B9F18DE)
  %20 = fdiv <2 x double> splat (double 2.000000e+06), %19
  %21 = getelementptr double, ptr @var_7, i64 %.reass
  store <2 x double> %20, ptr %21, align 8
  %index.next = add nuw i64 %index, 2
  %22 = icmp eq i64 %index.next, %n.vec
  br i1 %22, label %middle.block, label %vector.body, !llvm.loop !11

middle.block:                                     ; preds = %vector.body
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %.lr.ph, %middle.block
  %.ph = phi i64 [ %4, %.lr.ph ], [ %11, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %23 = phi i64 [ %30, %scalar.ph ], [ %.ph, %scalar.ph.preheader ]
  %24 = add i64 %17, %23
  %25 = getelementptr inbounds nuw double, ptr @var_6, i64 %24
  %26 = load double, ptr %25, align 8
  %27 = fmul double %26, 0x4070380A7B9F18DE
  %28 = fdiv double 2.000000e+06, %27
  %29 = getelementptr double, ptr @var_7, i64 %24
  store double %28, ptr %29, align 8
  %30 = add nsw i64 %23, 1
  %exitcond.not = icmp eq i64 %30, %5
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !12

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %.preheader
  %31 = add nsw i64 %15, 1
  %exitcond6.not = icmp eq i64 %31, %3
  br i1 %exitcond6.not, label %._crit_edge4, label %.preheader

._crit_edge4:                                     ; preds = %._crit_edge, %.preheader3
  %32 = add nsw i64 %12, 1
  %exitcond7.not = icmp eq i64 %32, %1
  br i1 %exitcond7.not, label %._crit_edge5, label %.preheader3

._crit_edge5:                                     ; preds = %._crit_edge4, %6
  ret void
}

define void @equation_5(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr {
  %7 = icmp slt i64 %0, %1
  br i1 %7, label %.preheader3.lr.ph, label %._crit_edge5

.preheader3.lr.ph:                                ; preds = %6
  %8 = icmp slt i64 %2, %3
  %9 = icmp slt i64 %4, %5
  br label %.preheader3

.preheader3:                                      ; preds = %._crit_edge4, %.preheader3.lr.ph
  %10 = phi i64 [ %0, %.preheader3.lr.ph ], [ %26, %._crit_edge4 ]
  br i1 %8, label %.preheader.lr.ph, label %._crit_edge4

.preheader.lr.ph:                                 ; preds = %.preheader3
  %11 = mul i64 %10, 24
  %12 = add i64 %11, -31
  br label %.preheader

.preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
  %13 = phi i64 [ %2, %.preheader.lr.ph ], [ %25, %._crit_edge ]
  br i1 %9, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %.preheader
  %14 = mul i64 %13, 6
  %15 = add i64 %12, %14
  br label %16

16:                                               ; preds = %16, %.lr.ph
  %17 = phi i64 [ %4, %.lr.ph ], [ %24, %16 ]
  %18 = add i64 %15, %17
  %19 = getelementptr inbounds nuw double, ptr @var_6, i64 %18
  %20 = load double, ptr %19, align 8
  %21 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %20)
  %22 = fadd double %21, 0xC070380A7B9F18DE
  %23 = getelementptr double, ptr @var_9, i64 %18
  store double %22, ptr %23, align 8
  %24 = add i64 %17, 1
  %exitcond.not = icmp eq i64 %24, %5
  br i1 %exitcond.not, label %._crit_edge, label %16

._crit_edge:                                      ; preds = %16, %.preheader
  %25 = add nsw i64 %13, 1
  %exitcond6.not = icmp eq i64 %25, %3
  br i1 %exitcond6.not, label %._crit_edge4, label %.preheader

._crit_edge4:                                     ; preds = %._crit_edge, %.preheader3
  %26 = add nsw i64 %10, 1
  %exitcond7.not = icmp eq i64 %26, %1
  br i1 %exitcond7.not, label %._crit_edge5, label %.preheader3

._crit_edge5:                                     ; preds = %._crit_edge4, %6
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_6(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr #0 {
  %7 = icmp slt i64 %0, %1
  br i1 %7, label %.preheader4.lr.ph, label %._crit_edge6

.preheader4.lr.ph:                                ; preds = %6
  %8 = icmp slt i64 %2, %3
  %9 = icmp slt i64 %4, %5
  %10 = mul i64 %0, 224
  %11 = mul i64 %2, 56
  %12 = shl i64 %4, 3
  %13 = mul i64 %0, 192
  %14 = mul i64 %2, 48
  %15 = sub i64 %5, %4
  %16 = shl i64 %15, 3
  %17 = sub i64 %3, %2
  %18 = sub i64 %1, %0
  %19 = getelementptr i8, ptr @var_6, i64 %13
  %20 = getelementptr i8, ptr %19, i64 %14
  %21 = getelementptr i8, ptr %20, i64 %12
  %22 = getelementptr i8, ptr @var_3, i64 %10
  %23 = getelementptr i8, ptr %22, i64 %11
  %24 = getelementptr i8, ptr %23, i64 %12
  %25 = getelementptr i8, ptr %24, i64 8
  %.neg = add i64 %2, 1
  %xtraiter = and i64 %17, 1
  %26 = icmp eq i64 %3, %.neg
  %unroll_iter = and i64 %17, -2
  %lcmp.mod.not = icmp eq i64 %xtraiter, 0
  br label %.preheader4

.preheader4:                                      ; preds = %._crit_edge5, %.preheader4.lr.ph
  %indvar = phi i64 [ 0, %.preheader4.lr.ph ], [ %indvar.next, %._crit_edge5 ]
  br i1 %8, label %.preheader.lr.ph, label %._crit_edge5

.preheader.lr.ph:                                 ; preds = %.preheader4
  %27 = mul i64 %indvar, 192
  %28 = mul i64 %indvar, 224
  %29 = getelementptr i8, ptr %21, i64 %27
  %30 = getelementptr i8, ptr %25, i64 %28
  br i1 %26, label %._crit_edge5.loopexit.unr-lcssa, label %.preheader

.preheader:                                       ; preds = %.preheader.lr.ph, %._crit_edge.1
  %indvar7 = phi i64 [ %indvar.next8.1, %._crit_edge.1 ], [ 0, %.preheader.lr.ph ]
  %niter = phi i64 [ %niter.next.1, %._crit_edge.1 ], [ 0, %.preheader.lr.ph ]
  br i1 %9, label %.lr.ph, label %._crit_edge.1

.lr.ph:                                           ; preds = %.preheader
  %31 = mul i64 %indvar7, 48
  %scevgep9 = getelementptr i8, ptr %29, i64 %31
  %32 = mul i64 %indvar7, 56
  %scevgep = getelementptr i8, ptr %30, i64 %32
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 8 %scevgep, ptr align 8 %scevgep9, i64 %16, i1 false)
  %indvar.next8 = or disjoint i64 %indvar7, 1
  %33 = mul i64 %indvar.next8, 48
  %scevgep9.1 = getelementptr i8, ptr %29, i64 %33
  %34 = mul i64 %indvar.next8, 56
  %scevgep.1 = getelementptr i8, ptr %30, i64 %34
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 8 %scevgep.1, ptr align 8 %scevgep9.1, i64 %16, i1 false)
  br label %._crit_edge.1

._crit_edge.1:                                    ; preds = %.preheader, %.lr.ph
  %indvar.next8.1 = add nuw i64 %indvar7, 2
  %niter.next.1 = add i64 %niter, 2
  %niter.ncmp.1 = icmp eq i64 %niter.next.1, %unroll_iter
  br i1 %niter.ncmp.1, label %._crit_edge5.loopexit.unr-lcssa, label %.preheader

._crit_edge5.loopexit.unr-lcssa:                  ; preds = %._crit_edge.1, %.preheader.lr.ph
  %indvar7.unr = phi i64 [ 0, %.preheader.lr.ph ], [ %indvar.next8.1, %._crit_edge.1 ]
  %.not = xor i1 %9, true
  %brmerge = select i1 %lcmp.mod.not, i1 true, i1 %.not
  br i1 %brmerge, label %._crit_edge5, label %.lr.ph.epil

.lr.ph.epil:                                      ; preds = %._crit_edge5.loopexit.unr-lcssa
  %35 = mul i64 %indvar7.unr, 48
  %scevgep9.epil = getelementptr i8, ptr %29, i64 %35
  %36 = mul i64 %indvar7.unr, 56
  %scevgep.epil = getelementptr i8, ptr %30, i64 %36
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 8 %scevgep.epil, ptr align 8 %scevgep9.epil, i64 %16, i1 false)
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %._crit_edge5.loopexit.unr-lcssa, %.lr.ph.epil, %.preheader4
  %indvar.next = add nuw i64 %indvar, 1
  %exitcond10.not = icmp eq i64 %indvar.next, %18
  br i1 %exitcond10.not, label %._crit_edge6, label %.preheader4

._crit_edge6:                                     ; preds = %._crit_edge5, %6
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_7(i64 %0, i64 %1, i64 %2, i64 %3) local_unnamed_addr #0 {
  %5 = icmp slt i64 %0, %1
  br i1 %5, label %.lr.ph4, label %._crit_edge5

.lr.ph4:                                          ; preds = %4
  %6 = icmp slt i64 %2, %3
  %7 = sub i64 %3, %2
  %xtraiter = and i64 %7, 7
  %lcmp.mod.not = icmp eq i64 %xtraiter, 0
  %8 = sub i64 %2, %3
  %9 = icmp ugt i64 %8, -8
  br label %10

10:                                               ; preds = %._crit_edge, %.lr.ph4
  %11 = phi i64 [ %0, %.lr.ph4 ], [ %44, %._crit_edge ]
  %12 = getelementptr double, ptr @var_12, i64 %11
  %13 = getelementptr i8, ptr %12, i64 -16
  %14 = load double, ptr %13, align 8
  br i1 %6, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %10
  %.idx = mul i64 %11, 224
  %15 = getelementptr i8, ptr @var_3, i64 %.idx
  br i1 %lcmp.mod.not, label %.prol.loopexit, label %.prol.preheader

.prol.preheader:                                  ; preds = %.lr.ph, %.prol.preheader
  %16 = phi i64 [ %19, %.prol.preheader ], [ %2, %.lr.ph ]
  %prol.iter = phi i64 [ %prol.iter.next, %.prol.preheader ], [ 0, %.lr.ph ]
  %.idx2.prol = mul i64 %16, 56
  %17 = getelementptr i8, ptr %15, i64 %.idx2.prol
  %18 = getelementptr i8, ptr %17, i64 -280
  store double %14, ptr %18, align 8
  %19 = add nsw i64 %16, 1
  %prol.iter.next = add i64 %prol.iter, 1
  %prol.iter.cmp.not = icmp eq i64 %prol.iter.next, %xtraiter
  br i1 %prol.iter.cmp.not, label %.prol.loopexit, label %.prol.preheader, !llvm.loop !13

.prol.loopexit:                                   ; preds = %.prol.preheader, %.lr.ph
  %.unr = phi i64 [ %2, %.lr.ph ], [ %19, %.prol.preheader ]
  br i1 %9, label %._crit_edge, label %.lr.ph.new

.lr.ph.new:                                       ; preds = %.prol.loopexit, %.lr.ph.new
  %20 = phi i64 [ %43, %.lr.ph.new ], [ %.unr, %.prol.loopexit ]
  %.idx2 = mul i64 %20, 56
  %21 = getelementptr i8, ptr %15, i64 %.idx2
  %22 = getelementptr i8, ptr %21, i64 -280
  store double %14, ptr %22, align 8
  %23 = mul i64 %20, 56
  %24 = getelementptr i8, ptr %15, i64 %23
  %25 = getelementptr i8, ptr %24, i64 -224
  store double %14, ptr %25, align 8
  %26 = mul i64 %20, 56
  %27 = getelementptr i8, ptr %15, i64 %26
  %28 = getelementptr i8, ptr %27, i64 -168
  store double %14, ptr %28, align 8
  %29 = mul i64 %20, 56
  %30 = getelementptr i8, ptr %15, i64 %29
  %31 = getelementptr i8, ptr %30, i64 -112
  store double %14, ptr %31, align 8
  %32 = mul i64 %20, 56
  %33 = getelementptr i8, ptr %15, i64 %32
  %34 = getelementptr i8, ptr %33, i64 -56
  store double %14, ptr %34, align 8
  %35 = mul i64 %20, 56
  %36 = getelementptr i8, ptr %15, i64 %35
  store double %14, ptr %36, align 8
  %37 = mul i64 %20, 56
  %38 = getelementptr i8, ptr %15, i64 %37
  %39 = getelementptr i8, ptr %38, i64 56
  store double %14, ptr %39, align 8
  %40 = mul i64 %20, 56
  %41 = getelementptr i8, ptr %15, i64 %40
  %42 = getelementptr i8, ptr %41, i64 112
  store double %14, ptr %42, align 8
  %43 = add nsw i64 %20, 8
  %exitcond.not.7 = icmp eq i64 %43, %3
  br i1 %exitcond.not.7, label %._crit_edge, label %.lr.ph.new

._crit_edge:                                      ; preds = %.prol.loopexit, %.lr.ph.new, %10
  %44 = add nsw i64 %11, 1
  %exitcond6.not = icmp eq i64 %44, %1
  br i1 %exitcond6.not, label %._crit_edge5, label %10

._crit_edge5:                                     ; preds = %._crit_edge, %4
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(write, argmem: none, inaccessiblemem: none)
define void @equation_8(i64 %0, i64 %1) local_unnamed_addr #2 {
  %3 = icmp slt i64 %0, %1
  br i1 %3, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %2
  %4 = sub i64 %1, %0
  %xtraiter = and i64 %4, 7
  %lcmp.mod.not = icmp eq i64 %xtraiter, 0
  br i1 %lcmp.mod.not, label %.lr.ph.prol.loopexit, label %.lr.ph.prol

.lr.ph.prol:                                      ; preds = %.lr.ph.preheader, %.lr.ph.prol
  %5 = phi i64 [ %8, %.lr.ph.prol ], [ %0, %.lr.ph.preheader ]
  %prol.iter = phi i64 [ %prol.iter.next, %.lr.ph.prol ], [ 0, %.lr.ph.preheader ]
  %.idx.prol = mul i64 %5, 56
  %6 = getelementptr i8, ptr @var_3, i64 %.idx.prol
  %7 = getelementptr i8, ptr %6, i64 -56
  store double 4.931500e+02, ptr %7, align 8
  %8 = add nsw i64 %5, 1
  %prol.iter.next = add i64 %prol.iter, 1
  %prol.iter.cmp.not = icmp eq i64 %prol.iter.next, %xtraiter
  br i1 %prol.iter.cmp.not, label %.lr.ph.prol.loopexit, label %.lr.ph.prol, !llvm.loop !15

.lr.ph.prol.loopexit:                             ; preds = %.lr.ph.prol, %.lr.ph.preheader
  %.unr = phi i64 [ %0, %.lr.ph.preheader ], [ %8, %.lr.ph.prol ]
  %9 = sub i64 %0, %1
  %10 = icmp ugt i64 %9, -8
  br i1 %10, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.prol.loopexit, %.lr.ph
  %11 = phi i64 [ %34, %.lr.ph ], [ %.unr, %.lr.ph.prol.loopexit ]
  %.idx = mul i64 %11, 56
  %12 = getelementptr i8, ptr @var_3, i64 %.idx
  %13 = getelementptr i8, ptr %12, i64 -56
  store double 4.931500e+02, ptr %13, align 8
  %14 = mul i64 %11, 56
  %15 = getelementptr i8, ptr @var_3, i64 %14
  store double 4.931500e+02, ptr %15, align 8
  %16 = mul i64 %11, 56
  %17 = getelementptr i8, ptr @var_3, i64 %16
  %18 = getelementptr i8, ptr %17, i64 56
  store double 4.931500e+02, ptr %18, align 8
  %19 = mul i64 %11, 56
  %20 = getelementptr i8, ptr @var_3, i64 %19
  %21 = getelementptr i8, ptr %20, i64 112
  store double 4.931500e+02, ptr %21, align 8
  %22 = mul i64 %11, 56
  %23 = getelementptr i8, ptr @var_3, i64 %22
  %24 = getelementptr i8, ptr %23, i64 168
  store double 4.931500e+02, ptr %24, align 8
  %25 = mul i64 %11, 56
  %26 = getelementptr i8, ptr @var_3, i64 %25
  %27 = getelementptr i8, ptr %26, i64 224
  store double 4.931500e+02, ptr %27, align 8
  %28 = mul i64 %11, 56
  %29 = getelementptr i8, ptr @var_3, i64 %28
  %30 = getelementptr i8, ptr %29, i64 280
  store double 4.931500e+02, ptr %30, align 8
  %31 = mul i64 %11, 56
  %32 = getelementptr i8, ptr @var_3, i64 %31
  %33 = getelementptr i8, ptr %32, i64 336
  store double 4.931500e+02, ptr %33, align 8
  %34 = add nsw i64 %11, 8
  %exitcond.not.7 = icmp eq i64 %34, %1
  br i1 %exitcond.not.7, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph.prol.loopexit, %.lr.ph, %2
  ret void
}

define void @equation_9(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr {
  %7 = icmp slt i64 %0, %1
  br i1 %7, label %.preheader3.lr.ph, label %._crit_edge5

.preheader3.lr.ph:                                ; preds = %6
  %8 = icmp slt i64 %2, %3
  %9 = icmp slt i64 %4, %5
  br label %.preheader3

.preheader3:                                      ; preds = %._crit_edge4, %.preheader3.lr.ph
  %10 = phi i64 [ %0, %.preheader3.lr.ph ], [ %68, %._crit_edge4 ]
  br i1 %8, label %.preheader.lr.ph, label %._crit_edge4

.preheader.lr.ph:                                 ; preds = %.preheader3
  %11 = mul i64 %10, 28
  %12 = add i64 %11, -36
  br label %.preheader

.preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
  %13 = phi i64 [ %2, %.preheader.lr.ph ], [ %67, %._crit_edge ]
  br i1 %9, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %.preheader
  %14 = mul i64 %13, 7
  %15 = add i64 %12, %14
  br label %thread-pre-split.i

thread-pre-split.i:                               ; preds = %thread-pre-split.i, %.lr.ph
  %16 = phi i64 [ %4, %.lr.ph ], [ %66, %thread-pre-split.i ]
  %17 = add i64 %15, %16
  %18 = getelementptr inbounds nuw double, ptr @var_3, i64 %17
  %19 = load double, ptr %18, align 8
  %20 = tail call ptr @llvm.stacksave.p0()
  %21 = fdiv double 5.126400e+02, %19
  %22 = fmul double %21, 4.125750e+00
  %23 = fmul double %21, 3.269730e+00
  %24 = fmul double %21, 3.774920e+00
  %25 = fmul double %21, 2.935740e+00
  %26 = fmul double %21, 8.237470e+00
  %27 = fmul double %21, 1.033120e+01
  %28 = fmul double %21, 5.332600e-01
  %29 = tail call double @_Mexp_f64_f64(double %22)
  call void @llvm.stackrestore.p0(ptr %20)
  %30 = fadd double %29, -1.000000e+00
  %31 = insertelement <2 x double> poison, double %21, i64 0
  %32 = insertelement <2 x double> %31, double %30, i64 1
  %33 = fdiv <2 x double> <double 0x400F34F61672324C, double 0x4046AD4E77FD67A0>, %32
  %shift = shufflevector <2 x double> %33, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop = fadd <2 x double> %33, %shift
  %34 = tail call ptr @llvm.stacksave.p0()
  %35 = tail call double @_Mexp_f64_f64(double %23)
  call void @llvm.stackrestore.p0(ptr %34)
  %36 = tail call ptr @llvm.stacksave.p0()
  %37 = tail call double @_Mexp_f64_f64(double %24)
  call void @llvm.stackrestore.p0(ptr %36)
  %38 = insertelement <2 x double> poison, double %35, i64 0
  %39 = insertelement <2 x double> %38, double %37, i64 1
  %40 = fadd <2 x double> %39, splat (double -1.000000e+00)
  %41 = fdiv <2 x double> <double 0x404DFA8AF7F1A4D9, double 0xC04EE407504DC2A2>, %40
  %foldExtExtBinop16 = fadd <2 x double> %foldExtExtBinop, %41
  %shift18 = shufflevector <2 x double> %41, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop19 = fadd <2 x double> %foldExtExtBinop16, %shift18
  %42 = tail call ptr @llvm.stacksave.p0()
  %43 = tail call double @_Mexp_f64_f64(double %25)
  call void @llvm.stackrestore.p0(ptr %42)
  %44 = tail call ptr @llvm.stacksave.p0()
  %45 = tail call double @_Mexp_f64_f64(double %26)
  call void @llvm.stackrestore.p0(ptr %44)
  %46 = insertelement <2 x double> poison, double %43, i64 0
  %47 = insertelement <2 x double> %46, double %45, i64 1
  %48 = fadd <2 x double> %47, splat (double -1.000000e+00)
  %49 = fdiv <2 x double> <double 0xC0324525CF236784, double 0x4037182B003F022E>, %48
  %foldExtExtBinop21 = fadd <2 x double> %foldExtExtBinop19, %49
  %shift23 = shufflevector <2 x double> %49, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop24 = fadd <2 x double> %foldExtExtBinop21, %shift23
  %50 = tail call ptr @llvm.stacksave.p0()
  %51 = tail call double @_Mexp_f64_f64(double %27)
  call void @llvm.stackrestore.p0(ptr %50)
  %52 = tail call ptr @llvm.stacksave.p0()
  %53 = tail call double @_Mexp_f64_f64(double %28)
  call void @llvm.stackrestore.p0(ptr %52)
  %54 = insertelement <2 x double> poison, double %51, i64 0
  %55 = insertelement <2 x double> %54, double %53, i64 1
  %56 = fadd <2 x double> %55, splat (double -1.000000e+00)
  %57 = fdiv <2 x double> <double 0x4026454310D46C32, double 0x3FE08BF868C4D601>, %56
  %foldExtExtBinop26 = fadd <2 x double> %foldExtExtBinop24, %57
  %shift28 = shufflevector <2 x double> %57, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop29 = fadd <2 x double> %foldExtExtBinop26, %shift28
  %58 = extractelement <2 x double> %foldExtExtBinop29, i64 0
  %59 = fmul double %19, 0x4070380A7B9F18DE
  %60 = fmul double %59, %21
  %61 = fmul double %60, %58
  %62 = fmul double %21, 1.361810e+03
  %63 = fdiv double %62, 5.126400e+02
  %64 = fsub double %61, %63
  %65 = getelementptr double, ptr @var_4, i64 %17
  store double %64, ptr %65, align 8
  %66 = add i64 %16, 1
  %exitcond.not = icmp eq i64 %66, %5
  br i1 %exitcond.not, label %._crit_edge, label %thread-pre-split.i

._crit_edge:                                      ; preds = %thread-pre-split.i, %.preheader
  %67 = add nsw i64 %13, 1
  %exitcond6.not = icmp eq i64 %67, %3
  br i1 %exitcond6.not, label %._crit_edge4, label %.preheader

._crit_edge4:                                     ; preds = %._crit_edge, %.preheader3
  %68 = add nsw i64 %10, 1
  %exitcond7.not = icmp eq i64 %68, %1
  br i1 %exitcond7.not, label %._crit_edge5, label %.preheader3

._crit_edge5:                                     ; preds = %._crit_edge4, %6
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_10(i64 %0, i64 %1) local_unnamed_addr #0 {
  %3 = load double, ptr @var_0, align 8
  %4 = load double, ptr @var, align 8
  %5 = icmp slt i64 %0, %1
  br i1 %5, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %2
  %6 = sub i64 %1, %0
  %min.iters.check = icmp ult i64 %6, 2
  br i1 %min.iters.check, label %.lr.ph.preheader7, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph.preheader
  %n.vec = and i64 %6, -2
  %7 = add i64 %0, %n.vec
  %broadcast.splatinsert = insertelement <2 x double> poison, double %3, i64 0
  %broadcast.splat = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <2 x i32> zeroinitializer
  %broadcast.splatinsert3 = insertelement <2 x double> poison, double %4, i64 0
  %broadcast.splat4 = shufflevector <2 x double> %broadcast.splatinsert3, <2 x double> poison, <2 x i32> zeroinitializer
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %offset.idx = add i64 %0, %index
  %8 = add i64 %offset.idx, -1
  %9 = getelementptr inbounds nuw double, ptr @var_8, i64 %8
  %wide.load = load <2 x double>, ptr %9, align 8
  %10 = getelementptr inbounds nuw double, ptr @var_10, i64 %8
  %wide.load5 = load <2 x double>, ptr %10, align 8
  %11 = mul nuw nsw i64 %8, 224
  %12 = mul nuw nsw i64 %offset.idx, 224
  %13 = getelementptr inbounds nuw i8, ptr @var_4, i64 %11
  %14 = getelementptr inbounds nuw i8, ptr @var_4, i64 %12
  %15 = getelementptr i8, ptr %13, i64 48
  %16 = getelementptr i8, ptr %14, i64 48
  %17 = load double, ptr %15, align 16
  %18 = load double, ptr %16, align 16
  %19 = insertelement <2 x double> poison, double %17, i64 0
  %20 = insertelement <2 x double> %19, double %18, i64 1
  %21 = fadd <2 x double> %20, zeroinitializer
  %22 = getelementptr i8, ptr %13, i64 104
  %23 = getelementptr i8, ptr %14, i64 104
  %24 = load double, ptr %22, align 8
  %25 = load double, ptr %23, align 8
  %26 = insertelement <2 x double> poison, double %24, i64 0
  %27 = insertelement <2 x double> %26, double %25, i64 1
  %28 = fadd <2 x double> %21, %27
  %29 = getelementptr i8, ptr %13, i64 160
  %30 = getelementptr i8, ptr %14, i64 160
  %31 = load double, ptr %29, align 16
  %32 = load double, ptr %30, align 16
  %33 = insertelement <2 x double> poison, double %31, i64 0
  %34 = insertelement <2 x double> %33, double %32, i64 1
  %35 = fadd <2 x double> %28, %34
  %36 = getelementptr i8, ptr %13, i64 216
  %37 = getelementptr i8, ptr %14, i64 216
  %38 = load double, ptr %36, align 8
  %39 = load double, ptr %37, align 8
  %40 = insertelement <2 x double> poison, double %38, i64 0
  %41 = insertelement <2 x double> %40, double %39, i64 1
  %42 = fadd <2 x double> %35, %41
  %43 = fmul <2 x double> %wide.load, splat (double 0x3F6B4E81B4E81B4F)
  %44 = fmul <2 x double> %43, %wide.load5
  %45 = fmul <2 x double> %broadcast.splat, %42
  %46 = getelementptr inbounds nuw double, ptr @var_5, i64 %8
  %wide.load6 = load <2 x double>, ptr %46, align 8
  %47 = fmul <2 x double> %broadcast.splat4, %wide.load6
  %48 = fsub <2 x double> %45, %47
  %49 = fdiv <2 x double> %48, %44
  %50 = getelementptr double, ptr @var_13, i64 %8
  store <2 x double> %49, ptr %50, align 8
  %index.next = add nuw i64 %index, 2
  %51 = icmp eq i64 %index.next, %n.vec
  br i1 %51, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %cmp.n = icmp eq i64 %6, %n.vec
  br i1 %cmp.n, label %._crit_edge, label %.lr.ph.preheader7

.lr.ph.preheader7:                                ; preds = %.lr.ph.preheader, %middle.block
  %.ph = phi i64 [ %0, %.lr.ph.preheader ], [ %7, %middle.block ]
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader7, %.lr.ph
  %52 = phi i64 [ %80, %.lr.ph ], [ %.ph, %.lr.ph.preheader7 ]
  %53 = add i64 %52, -1
  %54 = getelementptr inbounds nuw double, ptr @var_8, i64 %53
  %55 = load double, ptr %54, align 8
  %56 = getelementptr inbounds nuw double, ptr @var_10, i64 %53
  %57 = load double, ptr %56, align 8
  %.idx = mul nuw nsw i64 %53, 224
  %58 = getelementptr inbounds nuw i8, ptr @var_4, i64 %.idx
  %59 = getelementptr i8, ptr %58, i64 48
  %60 = load double, ptr %59, align 16
  %61 = fadd double %60, 0.000000e+00
  %62 = getelementptr i8, ptr %58, i64 104
  %63 = load double, ptr %62, align 8
  %64 = fadd double %61, %63
  %65 = getelementptr i8, ptr %58, i64 160
  %66 = load double, ptr %65, align 16
  %67 = fadd double %64, %66
  %68 = getelementptr i8, ptr %58, i64 216
  %69 = load double, ptr %68, align 8
  %70 = fadd double %67, %69
  %71 = fmul double %55, 0x3F6B4E81B4E81B4F
  %72 = fmul double %71, %57
  %73 = fmul double %3, %70
  %74 = getelementptr inbounds nuw double, ptr @var_5, i64 %53
  %75 = load double, ptr %74, align 8
  %76 = fmul double %4, %75
  %77 = fsub double %73, %76
  %78 = fdiv double %77, %72
  %79 = getelementptr double, ptr @var_13, i64 %53
  store double %78, ptr %79, align 8
  %80 = add nsw i64 %52, 1
  %exitcond3.not = icmp eq i64 %80, %1
  br i1 %exitcond3.not, label %._crit_edge, label %.lr.ph, !llvm.loop !17

._crit_edge:                                      ; preds = %.lr.ph, %middle.block, %2
  ret void
}

define void @equation_11(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr {
  %7 = load double, ptr @var, align 8
  %8 = tail call ptr @llvm.stacksave.p0()
  %9 = tail call double @_Mpow_f64_f64_f64(double %7, double 8.000000e-01)
  call void @llvm.stackrestore.p0(ptr %8)
  %10 = fmul double %9, 0x40615C71C71C71C7
  %11 = icmp slt i64 %0, %1
  br i1 %11, label %.preheader3.lr.ph, label %._crit_edge5

.preheader3.lr.ph:                                ; preds = %6
  %12 = icmp slt i64 %2, %3
  %13 = icmp slt i64 %4, %5
  %14 = sub i64 %5, %4
  %min.iters.check = icmp ult i64 %14, 4
  %n.vec = and i64 %14, -4
  %15 = add i64 %4, %n.vec
  %broadcast.splatinsert = insertelement <2 x double> poison, double %10, i64 0
  %broadcast.splat = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <2 x i32> zeroinitializer
  %cmp.n = icmp eq i64 %14, %n.vec
  br label %.preheader3

.preheader3:                                      ; preds = %._crit_edge4, %.preheader3.lr.ph
  %16 = phi i64 [ %0, %.preheader3.lr.ph ], [ %44, %._crit_edge4 ]
  br i1 %12, label %.preheader.lr.ph, label %._crit_edge4

.preheader.lr.ph:                                 ; preds = %.preheader3
  %17 = mul i64 %16, 24
  %18 = add i64 %17, -31
  br label %.preheader

.preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
  %19 = phi i64 [ %2, %.preheader.lr.ph ], [ %43, %._crit_edge ]
  br i1 %13, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %.preheader
  %20 = mul i64 %19, 6
  %21 = add i64 %18, %20
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %invariant.op = add i64 %4, %21
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %.reass = add i64 %index, %invariant.op
  %22 = getelementptr inbounds nuw double, ptr @var_11, i64 %.reass
  %23 = getelementptr inbounds nuw i8, ptr %22, i64 16
  %wide.load = load <2 x double>, ptr %22, align 8
  %wide.load15 = load <2 x double>, ptr %23, align 8
  %24 = getelementptr inbounds nuw double, ptr @var_6, i64 %.reass
  %25 = getelementptr inbounds nuw i8, ptr %24, i64 16
  %wide.load16 = load <2 x double>, ptr %24, align 8
  %wide.load17 = load <2 x double>, ptr %25, align 8
  %26 = fsub <2 x double> %wide.load, %wide.load16
  %27 = fsub <2 x double> %wide.load15, %wide.load17
  %28 = fmul <2 x double> %broadcast.splat, %26
  %29 = fmul <2 x double> %broadcast.splat, %27
  %30 = getelementptr double, ptr @var_2, i64 %.reass
  %31 = getelementptr i8, ptr %30, i64 16
  store <2 x double> %28, ptr %30, align 8
  store <2 x double> %29, ptr %31, align 8
  %index.next = add nuw i64 %index, 4
  %32 = icmp eq i64 %index.next, %n.vec
  br i1 %32, label %middle.block, label %vector.body, !llvm.loop !18

middle.block:                                     ; preds = %vector.body
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %.lr.ph, %middle.block
  %.ph = phi i64 [ %4, %.lr.ph ], [ %15, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %33 = phi i64 [ %42, %scalar.ph ], [ %.ph, %scalar.ph.preheader ]
  %34 = add i64 %21, %33
  %35 = getelementptr inbounds nuw double, ptr @var_11, i64 %34
  %36 = load double, ptr %35, align 8
  %37 = getelementptr inbounds nuw double, ptr @var_6, i64 %34
  %38 = load double, ptr %37, align 8
  %39 = fsub double %36, %38
  %40 = fmul double %10, %39
  %41 = getelementptr double, ptr @var_2, i64 %34
  store double %40, ptr %41, align 8
  %42 = add nsw i64 %33, 1
  %exitcond.not = icmp eq i64 %42, %5
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !19

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %.preheader
  %43 = add nsw i64 %19, 1
  %exitcond6.not = icmp eq i64 %43, %3
  br i1 %exitcond6.not, label %._crit_edge4, label %.preheader

._crit_edge4:                                     ; preds = %._crit_edge, %.preheader3
  %44 = add nsw i64 %16, 1
  %exitcond7.not = icmp eq i64 %44, %1
  br i1 %exitcond7.not, label %._crit_edge5, label %.preheader3

._crit_edge5:                                     ; preds = %._crit_edge4, %6
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_12(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr #0 {
  %7 = load double, ptr @var_0, align 8
  %8 = icmp slt i64 %0, %1
  br i1 %8, label %.lr.ph8, label %._crit_edge9

.lr.ph8:                                          ; preds = %6
  %9 = icmp slt i64 %2, %3
  %10 = icmp slt i64 %4, %5
  %11 = sub i64 %5, %4
  %min.iters.check = icmp ult i64 %11, 2
  %n.vec = and i64 %11, -2
  %12 = add i64 %4, %n.vec
  %broadcast.splatinsert = insertelement <2 x double> poison, double %7, i64 0
  %broadcast.splat = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <2 x i32> zeroinitializer
  %cmp.n = icmp eq i64 %11, %n.vec
  br label %13

13:                                               ; preds = %._crit_edge6, %.lr.ph8
  %14 = phi i64 [ %0, %.lr.ph8 ], [ %61, %._crit_edge6 ]
  br i1 %9, label %.lr.ph5, label %._crit_edge6

.lr.ph5:                                          ; preds = %13
  %15 = add i64 %14, -1
  %16 = mul nuw nsw i64 %15, 24
  %.idx = mul nuw nsw i64 %15, 224
  %17 = getelementptr inbounds nuw i8, ptr @var_4, i64 %.idx
  br label %18

18:                                               ; preds = %._crit_edge, %.lr.ph5
  %19 = phi i64 [ %2, %.lr.ph5 ], [ %60, %._crit_edge ]
  br i1 %10, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %18
  %20 = add i64 %19, -1
  %21 = mul nuw nsw i64 %20, 6
  %22 = add nuw nsw i64 %21, %16
  %.idx3 = mul nuw nsw i64 %20, 56
  %23 = getelementptr inbounds nuw i8, ptr %17, i64 %.idx3
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.body

vector.body:                                      ; preds = %.lr.ph, %vector.body
  %index = phi i64 [ %index.next, %vector.body ], [ 0, %.lr.ph ]
  %offset.idx = add i64 %4, %index
  %24 = add i64 %offset.idx, -1
  %25 = add nuw nsw i64 %22, %24
  %26 = getelementptr inbounds nuw double, ptr @var_7, i64 %25
  %wide.load = load <2 x double>, ptr %26, align 8
  %27 = fmul <2 x double> %wide.load, splat (double 1.375000e-02)
  %28 = getelementptr inbounds nuw double, ptr @var_9, i64 %25
  %wide.load15 = load <2 x double>, ptr %28, align 8
  %29 = fmul <2 x double> %27, %wide.load15
  %30 = getelementptr inbounds nuw double, ptr %23, i64 %24
  %wide.load16 = load <2 x double>, ptr %30, align 8
  %31 = getelementptr inbounds nuw double, ptr %23, i64 %offset.idx
  %wide.load17 = load <2 x double>, ptr %31, align 8
  %32 = fsub <2 x double> %wide.load16, %wide.load17
  %33 = fmul <2 x double> %broadcast.splat, %32
  %34 = getelementptr inbounds nuw double, ptr @var_2, i64 %25
  %wide.load18 = load <2 x double>, ptr %34, align 8
  %35 = fadd <2 x double> %wide.load18, %33
  %36 = fdiv <2 x double> %35, %29
  %37 = getelementptr double, ptr @var_14, i64 %25
  store <2 x double> %36, ptr %37, align 8
  %index.next = add nuw i64 %index, 2
  %38 = icmp eq i64 %index.next, %n.vec
  br i1 %38, label %middle.block, label %vector.body, !llvm.loop !20

middle.block:                                     ; preds = %vector.body
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %.lr.ph, %middle.block
  %.ph = phi i64 [ %4, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %39 = phi i64 [ %59, %scalar.ph ], [ %.ph, %scalar.ph.preheader ]
  %40 = add i64 %39, -1
  %41 = add nuw nsw i64 %22, %40
  %42 = getelementptr inbounds nuw double, ptr @var_7, i64 %41
  %43 = load double, ptr %42, align 8
  %44 = fmul double %43, 1.375000e-02
  %45 = getelementptr inbounds nuw double, ptr @var_9, i64 %41
  %46 = load double, ptr %45, align 8
  %47 = fmul double %44, %46
  %48 = getelementptr inbounds nuw double, ptr %23, i64 %40
  %49 = load double, ptr %48, align 8
  %50 = getelementptr inbounds nuw double, ptr %23, i64 %39
  %51 = load double, ptr %50, align 8
  %52 = fsub double %49, %51
  %53 = fmul double %7, %52
  %54 = getelementptr inbounds nuw double, ptr @var_2, i64 %41
  %55 = load double, ptr %54, align 8
  %56 = fadd double %55, %53
  %57 = fdiv double %56, %47
  %58 = getelementptr double, ptr @var_14, i64 %41
  store double %57, ptr %58, align 8
  %59 = add nsw i64 %39, 1
  %exitcond.not = icmp eq i64 %59, %5
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !21

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %18
  %60 = add nsw i64 %19, 1
  %exitcond10.not = icmp eq i64 %60, %3
  br i1 %exitcond10.not, label %._crit_edge6, label %18

._crit_edge6:                                     ; preds = %._crit_edge, %13
  %61 = add nsw i64 %14, 1
  %exitcond11.not = icmp eq i64 %61, %1
  br i1 %exitcond11.not, label %._crit_edge9, label %13

._crit_edge9:                                     ; preds = %._crit_edge6, %6
  ret void
}

define void @equation_13(i64 %0, i64 %1) local_unnamed_addr {
  %3 = load double, ptr @time, align 8
  %4 = fmul double %3, 0x3FB015BF92172844
  %5 = icmp slt i64 %0, %1
  br i1 %5, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %2, %.lr.ph
  %6 = phi i64 [ %17, %.lr.ph ], [ %0, %2 ]
  %7 = sitofp i64 %6 to double
  %8 = fmul double %7, 0x401921FB54442EEA
  %9 = fmul double %8, 2.500000e-01
  %10 = fadd double %4, %9
  %11 = tail call ptr @llvm.stacksave.p0()
  %12 = tail call double @_Msin_f64_f64(double %10)
  call void @llvm.stackrestore.p0(ptr %11)
  %13 = fadd double %12, 1.000000e+00
  %14 = fmul double %13, 0x40E4585555555555
  %15 = getelementptr double, ptr @var_1, i64 %6
  %16 = getelementptr i8, ptr %15, i64 -8
  store double %14, ptr %16, align 8
  %17 = add i64 %6, 1
  %exitcond.not = icmp eq i64 %17, %1
  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %2
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_14(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr #0 {
  %7 = icmp slt i64 %0, %1
  br i1 %7, label %.preheader.lr.ph, label %._crit_edge5

.preheader.lr.ph:                                 ; preds = %6
  %8 = icmp slt i64 %2, %3
  %9 = icmp slt i64 %4, %5
  %10 = sub i64 %5, %4
  %min.iters.check = icmp ult i64 %10, 2
  %n.vec = and i64 %10, -2
  %11 = add i64 %4, %n.vec
  %cmp.n = icmp eq i64 %10, %n.vec
  br label %.preheader

.preheader:                                       ; preds = %._crit_edge4, %.preheader.lr.ph
  %12 = phi i64 [ %0, %.preheader.lr.ph ], [ %37, %._crit_edge4 ]
  br i1 %8, label %.lr.ph3, label %._crit_edge4

.lr.ph3:                                          ; preds = %.preheader
  %13 = mul i64 %12, 24
  %14 = add i64 %13, -25
  br label %15

15:                                               ; preds = %._crit_edge, %.lr.ph3
  %16 = phi i64 [ %2, %.lr.ph3 ], [ %36, %._crit_edge ]
  %17 = add i64 %16, -1
  %18 = getelementptr inbounds nuw double, ptr @var_1, i64 %17
  %19 = load double, ptr %18, align 8
  %20 = fdiv double %19, 6.000000e+00
  br i1 %9, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %15
  %21 = mul nuw nsw i64 %17, 6
  %22 = add i64 %14, %21
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %broadcast.splatinsert = insertelement <2 x double> poison, double %20, i64 0
  %broadcast.splat = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <2 x i32> zeroinitializer
  %invariant.op = add i64 %4, %22
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %.reass = add i64 %index, %invariant.op
  %23 = getelementptr inbounds nuw double, ptr @var_2, i64 %.reass
  %wide.load = load <2 x double>, ptr %23, align 8
  %24 = fsub <2 x double> %broadcast.splat, %wide.load
  %25 = fdiv <2 x double> %24, splat (double 0x40615C71C71C71C7)
  %26 = getelementptr double, ptr @var_15, i64 %.reass
  store <2 x double> %25, ptr %26, align 8
  %index.next = add nuw i64 %index, 2
  %27 = icmp eq i64 %index.next, %n.vec
  br i1 %27, label %middle.block, label %vector.body, !llvm.loop !22

middle.block:                                     ; preds = %vector.body
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %.lr.ph, %middle.block
  %.ph = phi i64 [ %4, %.lr.ph ], [ %11, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %28 = phi i64 [ %35, %scalar.ph ], [ %.ph, %scalar.ph.preheader ]
  %29 = add i64 %22, %28
  %30 = getelementptr inbounds nuw double, ptr @var_2, i64 %29
  %31 = load double, ptr %30, align 8
  %32 = fsub double %20, %31
  %33 = fdiv double %32, 0x40615C71C71C71C7
  %34 = getelementptr double, ptr @var_15, i64 %29
  store double %33, ptr %34, align 8
  %35 = add nsw i64 %28, 1
  %exitcond.not = icmp eq i64 %35, %5
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !23

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %15
  %36 = add nsw i64 %16, 1
  %exitcond6.not = icmp eq i64 %36, %3
  br i1 %exitcond6.not, label %._crit_edge4, label %15

._crit_edge4:                                     ; preds = %._crit_edge, %.preheader
  %37 = add nsw i64 %12, 1
  %exitcond7.not = icmp eq i64 %37, %1
  br i1 %exitcond7.not, label %._crit_edge5, label %.preheader

._crit_edge5:                                     ; preds = %._crit_edge4, %6
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(write, argmem: none, inaccessiblemem: none)
define void @equation_15(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr #2 {
  %7 = icmp slt i64 %0, %1
  br i1 %7, label %.preheader2.lr.ph, label %._crit_edge4

.preheader2.lr.ph:                                ; preds = %6
  %8 = icmp slt i64 %2, %3
  %9 = icmp slt i64 %4, %5
  %10 = sub i64 %5, %4
  %min.iters.check = icmp ult i64 %10, 4
  %n.vec = and i64 %10, -4
  %11 = add i64 %4, %n.vec
  %cmp.n = icmp eq i64 %10, %n.vec
  br label %.preheader2

.preheader2:                                      ; preds = %._crit_edge3, %.preheader2.lr.ph
  %12 = phi i64 [ %0, %.preheader2.lr.ph ], [ %24, %._crit_edge3 ]
  br i1 %8, label %.preheader.lr.ph, label %._crit_edge3

.preheader.lr.ph:                                 ; preds = %.preheader2
  %.idx = mul i64 %12, 192
  %13 = getelementptr i8, ptr @var_6, i64 %.idx
  br label %.preheader

.preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
  %14 = phi i64 [ %2, %.preheader.lr.ph ], [ %23, %._crit_edge ]
  br i1 %9, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %.preheader
  %.idx1 = mul i64 %14, 48
  %15 = getelementptr i8, ptr %13, i64 %.idx1
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %16 = getelementptr double, ptr %15, i64 %4
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %17 = getelementptr double, ptr %16, i64 %index
  %18 = getelementptr i8, ptr %17, i64 16
  store <2 x double> splat (double 4.931500e+02), ptr %17, align 8
  store <2 x double> splat (double 4.931500e+02), ptr %18, align 8
  %index.next = add nuw i64 %index, 4
  %19 = icmp eq i64 %index.next, %n.vec
  br i1 %19, label %middle.block, label %vector.body, !llvm.loop !24

middle.block:                                     ; preds = %vector.body
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %.lr.ph, %middle.block
  %.ph = phi i64 [ %4, %.lr.ph ], [ %11, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %20 = phi i64 [ %22, %scalar.ph ], [ %.ph, %scalar.ph.preheader ]
  %21 = getelementptr double, ptr %15, i64 %20
  store double 4.931500e+02, ptr %21, align 8
  %22 = add nsw i64 %20, 1
  %exitcond.not = icmp eq i64 %22, %5
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !25

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %.preheader
  %23 = add nsw i64 %14, 1
  %exitcond5.not = icmp eq i64 %23, %3
  br i1 %exitcond5.not, label %._crit_edge3, label %.preheader

._crit_edge3:                                     ; preds = %._crit_edge, %.preheader2
  %24 = add nsw i64 %12, 1
  %exitcond6.not = icmp eq i64 %24, %1
  br i1 %exitcond6.not, label %._crit_edge4, label %.preheader2

._crit_edge4:                                     ; preds = %._crit_edge3, %6
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(write, argmem: none, inaccessiblemem: none)
define void @equation_16(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr #2 {
  %7 = icmp slt i64 %0, %1
  br i1 %7, label %.preheader2.lr.ph, label %._crit_edge4

.preheader2.lr.ph:                                ; preds = %6
  %8 = icmp slt i64 %2, %3
  %9 = icmp slt i64 %4, %5
  %10 = sub i64 %5, %4
  %min.iters.check = icmp ult i64 %10, 4
  %n.vec = and i64 %10, -4
  %11 = add i64 %4, %n.vec
  %cmp.n = icmp eq i64 %10, %n.vec
  br label %.preheader2

.preheader2:                                      ; preds = %._crit_edge3, %.preheader2.lr.ph
  %12 = phi i64 [ %0, %.preheader2.lr.ph ], [ %24, %._crit_edge3 ]
  br i1 %8, label %.preheader.lr.ph, label %._crit_edge3

.preheader.lr.ph:                                 ; preds = %.preheader2
  %.idx = mul i64 %12, 192
  %13 = getelementptr i8, ptr @var_11, i64 %.idx
  br label %.preheader

.preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
  %14 = phi i64 [ %2, %.preheader.lr.ph ], [ %23, %._crit_edge ]
  br i1 %9, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %.preheader
  %.idx1 = mul i64 %14, 48
  %15 = getelementptr i8, ptr %13, i64 %.idx1
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %16 = getelementptr double, ptr %15, i64 %4
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %17 = getelementptr double, ptr %16, i64 %index
  %18 = getelementptr i8, ptr %17, i64 16
  store <2 x double> splat (double 4.931500e+02), ptr %17, align 8
  store <2 x double> splat (double 4.931500e+02), ptr %18, align 8
  %index.next = add nuw i64 %index, 4
  %19 = icmp eq i64 %index.next, %n.vec
  br i1 %19, label %middle.block, label %vector.body, !llvm.loop !26

middle.block:                                     ; preds = %vector.body
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %.lr.ph, %middle.block
  %.ph = phi i64 [ %4, %.lr.ph ], [ %11, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %20 = phi i64 [ %22, %scalar.ph ], [ %.ph, %scalar.ph.preheader ]
  %21 = getelementptr double, ptr %15, i64 %20
  store double 4.931500e+02, ptr %21, align 8
  %22 = add nsw i64 %20, 1
  %exitcond.not = icmp eq i64 %22, %5
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !27

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %.preheader
  %23 = add nsw i64 %14, 1
  %exitcond5.not = icmp eq i64 %23, %3
  br i1 %exitcond5.not, label %._crit_edge3, label %.preheader

._crit_edge3:                                     ; preds = %._crit_edge, %.preheader2
  %24 = add nsw i64 %12, 1
  %exitcond6.not = icmp eq i64 %24, %1
  br i1 %exitcond6.not, label %._crit_edge4, label %.preheader2

._crit_edge4:                                     ; preds = %._crit_edge3, %6
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(write, argmem: none, inaccessiblemem: none)
define void @equation_17(i64 %0, i64 %1) local_unnamed_addr #2 {
  %3 = icmp slt i64 %0, %1
  br i1 %3, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %2
  %4 = sub i64 %1, %0
  %min.iters.check = icmp ult i64 %4, 4
  br i1 %min.iters.check, label %.lr.ph.preheader2, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph.preheader
  %n.vec = and i64 %4, -4
  %5 = add i64 %0, %n.vec
  %6 = getelementptr double, ptr @var_12, i64 %0
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %7 = getelementptr double, ptr %6, i64 %index
  %8 = getelementptr i8, ptr %7, i64 16
  store <2 x double> splat (double 4.931500e+02), ptr %7, align 8
  store <2 x double> splat (double 4.931500e+02), ptr %8, align 8
  %index.next = add nuw i64 %index, 4
  %9 = icmp eq i64 %index.next, %n.vec
  br i1 %9, label %middle.block, label %vector.body, !llvm.loop !28

middle.block:                                     ; preds = %vector.body
  %cmp.n = icmp eq i64 %4, %n.vec
  br i1 %cmp.n, label %._crit_edge, label %.lr.ph.preheader2

.lr.ph.preheader2:                                ; preds = %.lr.ph.preheader, %middle.block
  %.ph = phi i64 [ %0, %.lr.ph.preheader ], [ %5, %middle.block ]
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader2, %.lr.ph
  %10 = phi i64 [ %12, %.lr.ph ], [ %.ph, %.lr.ph.preheader2 ]
  %11 = getelementptr double, ptr @var_12, i64 %10
  store double 4.931500e+02, ptr %11, align 8
  %12 = add nsw i64 %10, 1
  %exitcond.not = icmp eq i64 %12, %1
  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph, !llvm.loop !29

._crit_edge:                                      ; preds = %.lr.ph, %middle.block, %2
  ret void
}

define void @equation_18() local_unnamed_addr {
  %1 = load double, ptr @time, align 8
  %2 = fmul double %1, 0x3FCACEE9F37BEDC6
  %3 = tail call double @_Msin_f64_f64(double %2)
  %4 = fmul double %3, 2.000000e-01
  %5 = fadd double %4, 1.000000e+00
  store double %5, ptr @var, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_19() local_unnamed_addr #1 {
  %1 = load double, ptr @var, align 8
  %2 = fmul double %1, 2.500000e-01
  store double %2, ptr @var_0, align 8
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_20(i64 %0, i64 %1) local_unnamed_addr #0 {
  %3 = icmp slt i64 %0, %1
  br i1 %3, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %2
  %4 = sub i64 %1, %0
  %min.iters.check = icmp ult i64 %4, 2
  br i1 %min.iters.check, label %.lr.ph.preheader2, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph.preheader
  %n.vec = and i64 %4, -2
  %5 = add i64 %0, %n.vec
  %invariant.op = add i64 %0, -1
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %.reass = add i64 %index, %invariant.op
  %6 = getelementptr inbounds nuw double, ptr @var_12, i64 %.reass
  %wide.load = load <2 x double>, ptr %6, align 8
  %7 = fmul <2 x double> %wide.load, splat (double 0x4070380A7B9F18DE)
  %8 = fdiv <2 x double> splat (double 2.000000e+06), %7
  %9 = getelementptr double, ptr @var_8, i64 %.reass
  store <2 x double> %8, ptr %9, align 8
  %index.next = add nuw i64 %index, 2
  %10 = icmp eq i64 %index.next, %n.vec
  br i1 %10, label %middle.block, label %vector.body, !llvm.loop !30

middle.block:                                     ; preds = %vector.body
  %cmp.n = icmp eq i64 %4, %n.vec
  br i1 %cmp.n, label %._crit_edge, label %.lr.ph.preheader2

.lr.ph.preheader2:                                ; preds = %.lr.ph.preheader, %middle.block
  %.ph = phi i64 [ %0, %.lr.ph.preheader ], [ %5, %middle.block ]
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader2, %.lr.ph
  %11 = phi i64 [ %18, %.lr.ph ], [ %.ph, %.lr.ph.preheader2 ]
  %12 = add i64 %11, -1
  %13 = getelementptr inbounds nuw double, ptr @var_12, i64 %12
  %14 = load double, ptr %13, align 8
  %15 = fmul double %14, 0x4070380A7B9F18DE
  %16 = fdiv double 2.000000e+06, %15
  %17 = getelementptr double, ptr @var_8, i64 %12
  store double %16, ptr %17, align 8
  %18 = add nsw i64 %11, 1
  %exitcond.not = icmp eq i64 %18, %1
  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph, !llvm.loop !31

._crit_edge:                                      ; preds = %.lr.ph, %middle.block, %2
  ret void
}

define void @equation_21(i64 %0, i64 %1) local_unnamed_addr {
  %3 = icmp slt i64 %0, %1
  br i1 %3, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %2, %.lr.ph
  %4 = phi i64 [ %54, %.lr.ph ], [ %0, %2 ]
  %5 = add i64 %4, -1
  %6 = getelementptr inbounds nuw double, ptr @var_12, i64 %5
  %7 = load double, ptr %6, align 8
  %8 = tail call ptr @llvm.stacksave.p0()
  %9 = fdiv double 5.126400e+02, %7
  %10 = fmul double %9, 4.125750e+00
  %11 = fmul double %9, 3.269730e+00
  %12 = fmul double %9, 3.774920e+00
  %13 = fmul double %9, 2.935740e+00
  %14 = fmul double %9, 8.237470e+00
  %15 = fmul double %9, 1.033120e+01
  %16 = fmul double %9, 5.332600e-01
  %17 = tail call double @_Mexp_f64_f64(double %10)
  call void @llvm.stackrestore.p0(ptr %8)
  %18 = fadd double %17, -1.000000e+00
  %19 = insertelement <2 x double> poison, double %9, i64 0
  %20 = insertelement <2 x double> %19, double %18, i64 1
  %21 = fdiv <2 x double> <double 0x400F34F61672324C, double 0x4046AD4E77FD67A0>, %20
  %shift = shufflevector <2 x double> %21, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop = fadd <2 x double> %21, %shift
  %22 = tail call ptr @llvm.stacksave.p0()
  %23 = tail call double @_Mexp_f64_f64(double %11)
  call void @llvm.stackrestore.p0(ptr %22)
  %24 = tail call ptr @llvm.stacksave.p0()
  %25 = tail call double @_Mexp_f64_f64(double %12)
  call void @llvm.stackrestore.p0(ptr %24)
  %26 = insertelement <2 x double> poison, double %23, i64 0
  %27 = insertelement <2 x double> %26, double %25, i64 1
  %28 = fadd <2 x double> %27, splat (double -1.000000e+00)
  %29 = fdiv <2 x double> <double 0x404DFA8AF7F1A4D9, double 0xC04EE407504DC2A2>, %28
  %foldExtExtBinop3 = fadd <2 x double> %foldExtExtBinop, %29
  %shift5 = shufflevector <2 x double> %29, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop6 = fadd <2 x double> %foldExtExtBinop3, %shift5
  %30 = tail call ptr @llvm.stacksave.p0()
  %31 = tail call double @_Mexp_f64_f64(double %13)
  call void @llvm.stackrestore.p0(ptr %30)
  %32 = tail call ptr @llvm.stacksave.p0()
  %33 = tail call double @_Mexp_f64_f64(double %14)
  call void @llvm.stackrestore.p0(ptr %32)
  %34 = insertelement <2 x double> poison, double %31, i64 0
  %35 = insertelement <2 x double> %34, double %33, i64 1
  %36 = fadd <2 x double> %35, splat (double -1.000000e+00)
  %37 = fdiv <2 x double> <double 0xC0324525CF236784, double 0x4037182B003F022E>, %36
  %foldExtExtBinop8 = fadd <2 x double> %foldExtExtBinop6, %37
  %shift10 = shufflevector <2 x double> %37, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop11 = fadd <2 x double> %foldExtExtBinop8, %shift10
  %38 = tail call ptr @llvm.stacksave.p0()
  %39 = tail call double @_Mexp_f64_f64(double %15)
  call void @llvm.stackrestore.p0(ptr %38)
  %40 = tail call ptr @llvm.stacksave.p0()
  %41 = tail call double @_Mexp_f64_f64(double %16)
  call void @llvm.stackrestore.p0(ptr %40)
  %42 = insertelement <2 x double> poison, double %39, i64 0
  %43 = insertelement <2 x double> %42, double %41, i64 1
  %44 = fadd <2 x double> %43, splat (double -1.000000e+00)
  %45 = fdiv <2 x double> <double 0x4026454310D46C32, double 0x3FE08BF868C4D601>, %44
  %foldExtExtBinop13 = fadd <2 x double> %foldExtExtBinop11, %45
  %shift15 = shufflevector <2 x double> %45, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop16 = fadd <2 x double> %foldExtExtBinop13, %shift15
  %46 = extractelement <2 x double> %foldExtExtBinop16, i64 0
  %47 = fmul double %7, 0x4070380A7B9F18DE
  %48 = fmul double %47, %9
  %49 = fmul double %48, %46
  %50 = fmul double %9, 1.361810e+03
  %51 = fdiv double %50, 5.126400e+02
  %52 = fsub double %49, %51
  %53 = getelementptr double, ptr @var_5, i64 %5
  store double %52, ptr %53, align 8
  %54 = add i64 %4, 1
  %exitcond.not = icmp eq i64 %54, %1
  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %2
  ret void
}

define void @equation_22(i64 %0, i64 %1) local_unnamed_addr {
  %3 = icmp slt i64 %0, %1
  br i1 %3, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %2, %.lr.ph
  %4 = phi i64 [ %11, %.lr.ph ], [ %0, %2 ]
  %5 = add i64 %4, -1
  %6 = getelementptr inbounds nuw double, ptr @var_12, i64 %5
  %7 = load double, ptr %6, align 8
  %8 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %7)
  %9 = fadd double %8, 0xC070380A7B9F18DE
  %10 = getelementptr double, ptr @var_10, i64 %5
  store double %9, ptr %10, align 8
  %11 = add i64 %4, 1
  %exitcond.not = icmp eq i64 %11, %1
  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %2
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_23(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr #0 {
  %7 = icmp slt i64 %0, %1
  br i1 %7, label %.preheader3.lr.ph, label %._crit_edge5

.preheader3.lr.ph:                                ; preds = %6
  %8 = icmp slt i64 %2, %3
  %9 = icmp slt i64 %4, %5
  %10 = sub i64 %5, %4
  %min.iters.check = icmp ult i64 %10, 2
  %n.vec = and i64 %10, -2
  %11 = add i64 %4, %n.vec
  %cmp.n = icmp eq i64 %10, %n.vec
  br label %.preheader3

.preheader3:                                      ; preds = %._crit_edge4, %.preheader3.lr.ph
  %12 = phi i64 [ %0, %.preheader3.lr.ph ], [ %32, %._crit_edge4 ]
  br i1 %8, label %.preheader.lr.ph, label %._crit_edge4

.preheader.lr.ph:                                 ; preds = %.preheader3
  %13 = mul i64 %12, 24
  %14 = add i64 %13, -31
  br label %.preheader

.preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
  %15 = phi i64 [ %2, %.preheader.lr.ph ], [ %31, %._crit_edge ]
  br i1 %9, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %.preheader
  %16 = mul i64 %15, 6
  %17 = add i64 %14, %16
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %invariant.op = add i64 %4, %17
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %.reass = add i64 %index, %invariant.op
  %18 = getelementptr inbounds nuw double, ptr @var_6, i64 %.reass
  %wide.load = load <2 x double>, ptr %18, align 8
  %19 = fmul <2 x double> %wide.load, splat (double 0x4070380A7B9F18DE)
  %20 = fdiv <2 x double> splat (double 2.000000e+06), %19
  %21 = getelementptr double, ptr @var_7, i64 %.reass
  store <2 x double> %20, ptr %21, align 8
  %index.next = add nuw i64 %index, 2
  %22 = icmp eq i64 %index.next, %n.vec
  br i1 %22, label %middle.block, label %vector.body, !llvm.loop !32

middle.block:                                     ; preds = %vector.body
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %.lr.ph, %middle.block
  %.ph = phi i64 [ %4, %.lr.ph ], [ %11, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %23 = phi i64 [ %30, %scalar.ph ], [ %.ph, %scalar.ph.preheader ]
  %24 = add i64 %17, %23
  %25 = getelementptr inbounds nuw double, ptr @var_6, i64 %24
  %26 = load double, ptr %25, align 8
  %27 = fmul double %26, 0x4070380A7B9F18DE
  %28 = fdiv double 2.000000e+06, %27
  %29 = getelementptr double, ptr @var_7, i64 %24
  store double %28, ptr %29, align 8
  %30 = add nsw i64 %23, 1
  %exitcond.not = icmp eq i64 %30, %5
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !33

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %.preheader
  %31 = add nsw i64 %15, 1
  %exitcond6.not = icmp eq i64 %31, %3
  br i1 %exitcond6.not, label %._crit_edge4, label %.preheader

._crit_edge4:                                     ; preds = %._crit_edge, %.preheader3
  %32 = add nsw i64 %12, 1
  %exitcond7.not = icmp eq i64 %32, %1
  br i1 %exitcond7.not, label %._crit_edge5, label %.preheader3

._crit_edge5:                                     ; preds = %._crit_edge4, %6
  ret void
}

define void @equation_24(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr {
  %7 = icmp slt i64 %0, %1
  br i1 %7, label %.preheader3.lr.ph, label %._crit_edge5

.preheader3.lr.ph:                                ; preds = %6
  %8 = icmp slt i64 %2, %3
  %9 = icmp slt i64 %4, %5
  br label %.preheader3

.preheader3:                                      ; preds = %._crit_edge4, %.preheader3.lr.ph
  %10 = phi i64 [ %0, %.preheader3.lr.ph ], [ %26, %._crit_edge4 ]
  br i1 %8, label %.preheader.lr.ph, label %._crit_edge4

.preheader.lr.ph:                                 ; preds = %.preheader3
  %11 = mul i64 %10, 24
  %12 = add i64 %11, -31
  br label %.preheader

.preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
  %13 = phi i64 [ %2, %.preheader.lr.ph ], [ %25, %._crit_edge ]
  br i1 %9, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %.preheader
  %14 = mul i64 %13, 6
  %15 = add i64 %12, %14
  br label %16

16:                                               ; preds = %16, %.lr.ph
  %17 = phi i64 [ %4, %.lr.ph ], [ %24, %16 ]
  %18 = add i64 %15, %17
  %19 = getelementptr inbounds nuw double, ptr @var_6, i64 %18
  %20 = load double, ptr %19, align 8
  %21 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %20)
  %22 = fadd double %21, 0xC070380A7B9F18DE
  %23 = getelementptr double, ptr @var_9, i64 %18
  store double %22, ptr %23, align 8
  %24 = add i64 %17, 1
  %exitcond.not = icmp eq i64 %24, %5
  br i1 %exitcond.not, label %._crit_edge, label %16

._crit_edge:                                      ; preds = %16, %.preheader
  %25 = add nsw i64 %13, 1
  %exitcond6.not = icmp eq i64 %25, %3
  br i1 %exitcond6.not, label %._crit_edge4, label %.preheader

._crit_edge4:                                     ; preds = %._crit_edge, %.preheader3
  %26 = add nsw i64 %10, 1
  %exitcond7.not = icmp eq i64 %26, %1
  br i1 %exitcond7.not, label %._crit_edge5, label %.preheader3

._crit_edge5:                                     ; preds = %._crit_edge4, %6
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_25(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr #0 {
  %7 = icmp slt i64 %0, %1
  br i1 %7, label %.preheader4.lr.ph, label %._crit_edge6

.preheader4.lr.ph:                                ; preds = %6
  %8 = icmp slt i64 %2, %3
  %9 = icmp slt i64 %4, %5
  %10 = mul i64 %0, 224
  %11 = mul i64 %2, 56
  %12 = shl i64 %4, 3
  %13 = mul i64 %0, 192
  %14 = mul i64 %2, 48
  %15 = sub i64 %5, %4
  %16 = shl i64 %15, 3
  %17 = sub i64 %3, %2
  %18 = sub i64 %1, %0
  %19 = getelementptr i8, ptr @var_6, i64 %13
  %20 = getelementptr i8, ptr %19, i64 %14
  %21 = getelementptr i8, ptr %20, i64 %12
  %22 = getelementptr i8, ptr @var_3, i64 %10
  %23 = getelementptr i8, ptr %22, i64 %11
  %24 = getelementptr i8, ptr %23, i64 %12
  %25 = getelementptr i8, ptr %24, i64 8
  %.neg = add i64 %2, 1
  %xtraiter = and i64 %17, 1
  %26 = icmp eq i64 %3, %.neg
  %unroll_iter = and i64 %17, -2
  %lcmp.mod.not = icmp eq i64 %xtraiter, 0
  br label %.preheader4

.preheader4:                                      ; preds = %._crit_edge5, %.preheader4.lr.ph
  %indvar = phi i64 [ 0, %.preheader4.lr.ph ], [ %indvar.next, %._crit_edge5 ]
  br i1 %8, label %.preheader.lr.ph, label %._crit_edge5

.preheader.lr.ph:                                 ; preds = %.preheader4
  %27 = mul i64 %indvar, 192
  %28 = mul i64 %indvar, 224
  %29 = getelementptr i8, ptr %21, i64 %27
  %30 = getelementptr i8, ptr %25, i64 %28
  br i1 %26, label %._crit_edge5.loopexit.unr-lcssa, label %.preheader

.preheader:                                       ; preds = %.preheader.lr.ph, %._crit_edge.1
  %indvar7 = phi i64 [ %indvar.next8.1, %._crit_edge.1 ], [ 0, %.preheader.lr.ph ]
  %niter = phi i64 [ %niter.next.1, %._crit_edge.1 ], [ 0, %.preheader.lr.ph ]
  br i1 %9, label %.lr.ph, label %._crit_edge.1

.lr.ph:                                           ; preds = %.preheader
  %31 = mul i64 %indvar7, 48
  %scevgep9 = getelementptr i8, ptr %29, i64 %31
  %32 = mul i64 %indvar7, 56
  %scevgep = getelementptr i8, ptr %30, i64 %32
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 8 %scevgep, ptr align 8 %scevgep9, i64 %16, i1 false)
  %indvar.next8 = or disjoint i64 %indvar7, 1
  %33 = mul i64 %indvar.next8, 48
  %scevgep9.1 = getelementptr i8, ptr %29, i64 %33
  %34 = mul i64 %indvar.next8, 56
  %scevgep.1 = getelementptr i8, ptr %30, i64 %34
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 8 %scevgep.1, ptr align 8 %scevgep9.1, i64 %16, i1 false)
  br label %._crit_edge.1

._crit_edge.1:                                    ; preds = %.preheader, %.lr.ph
  %indvar.next8.1 = add nuw i64 %indvar7, 2
  %niter.next.1 = add i64 %niter, 2
  %niter.ncmp.1 = icmp eq i64 %niter.next.1, %unroll_iter
  br i1 %niter.ncmp.1, label %._crit_edge5.loopexit.unr-lcssa, label %.preheader

._crit_edge5.loopexit.unr-lcssa:                  ; preds = %._crit_edge.1, %.preheader.lr.ph
  %indvar7.unr = phi i64 [ 0, %.preheader.lr.ph ], [ %indvar.next8.1, %._crit_edge.1 ]
  %.not = xor i1 %9, true
  %brmerge = select i1 %lcmp.mod.not, i1 true, i1 %.not
  br i1 %brmerge, label %._crit_edge5, label %.lr.ph.epil

.lr.ph.epil:                                      ; preds = %._crit_edge5.loopexit.unr-lcssa
  %35 = mul i64 %indvar7.unr, 48
  %scevgep9.epil = getelementptr i8, ptr %29, i64 %35
  %36 = mul i64 %indvar7.unr, 56
  %scevgep.epil = getelementptr i8, ptr %30, i64 %36
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 8 %scevgep.epil, ptr align 8 %scevgep9.epil, i64 %16, i1 false)
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %._crit_edge5.loopexit.unr-lcssa, %.lr.ph.epil, %.preheader4
  %indvar.next = add nuw i64 %indvar, 1
  %exitcond10.not = icmp eq i64 %indvar.next, %18
  br i1 %exitcond10.not, label %._crit_edge6, label %.preheader4

._crit_edge6:                                     ; preds = %._crit_edge5, %6
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_26(i64 %0, i64 %1, i64 %2, i64 %3) local_unnamed_addr #0 {
  %5 = icmp slt i64 %0, %1
  br i1 %5, label %.lr.ph4, label %._crit_edge5

.lr.ph4:                                          ; preds = %4
  %6 = icmp slt i64 %2, %3
  %7 = sub i64 %3, %2
  %xtraiter = and i64 %7, 7
  %lcmp.mod.not = icmp eq i64 %xtraiter, 0
  %8 = sub i64 %2, %3
  %9 = icmp ugt i64 %8, -8
  br label %10

10:                                               ; preds = %._crit_edge, %.lr.ph4
  %11 = phi i64 [ %0, %.lr.ph4 ], [ %44, %._crit_edge ]
  %12 = getelementptr double, ptr @var_12, i64 %11
  %13 = getelementptr i8, ptr %12, i64 -16
  %14 = load double, ptr %13, align 8
  br i1 %6, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %10
  %.idx = mul i64 %11, 224
  %15 = getelementptr i8, ptr @var_3, i64 %.idx
  br i1 %lcmp.mod.not, label %.prol.loopexit, label %.prol.preheader

.prol.preheader:                                  ; preds = %.lr.ph, %.prol.preheader
  %16 = phi i64 [ %19, %.prol.preheader ], [ %2, %.lr.ph ]
  %prol.iter = phi i64 [ %prol.iter.next, %.prol.preheader ], [ 0, %.lr.ph ]
  %.idx2.prol = mul i64 %16, 56
  %17 = getelementptr i8, ptr %15, i64 %.idx2.prol
  %18 = getelementptr i8, ptr %17, i64 -280
  store double %14, ptr %18, align 8
  %19 = add nsw i64 %16, 1
  %prol.iter.next = add i64 %prol.iter, 1
  %prol.iter.cmp.not = icmp eq i64 %prol.iter.next, %xtraiter
  br i1 %prol.iter.cmp.not, label %.prol.loopexit, label %.prol.preheader, !llvm.loop !34

.prol.loopexit:                                   ; preds = %.prol.preheader, %.lr.ph
  %.unr = phi i64 [ %2, %.lr.ph ], [ %19, %.prol.preheader ]
  br i1 %9, label %._crit_edge, label %.lr.ph.new

.lr.ph.new:                                       ; preds = %.prol.loopexit, %.lr.ph.new
  %20 = phi i64 [ %43, %.lr.ph.new ], [ %.unr, %.prol.loopexit ]
  %.idx2 = mul i64 %20, 56
  %21 = getelementptr i8, ptr %15, i64 %.idx2
  %22 = getelementptr i8, ptr %21, i64 -280
  store double %14, ptr %22, align 8
  %23 = mul i64 %20, 56
  %24 = getelementptr i8, ptr %15, i64 %23
  %25 = getelementptr i8, ptr %24, i64 -224
  store double %14, ptr %25, align 8
  %26 = mul i64 %20, 56
  %27 = getelementptr i8, ptr %15, i64 %26
  %28 = getelementptr i8, ptr %27, i64 -168
  store double %14, ptr %28, align 8
  %29 = mul i64 %20, 56
  %30 = getelementptr i8, ptr %15, i64 %29
  %31 = getelementptr i8, ptr %30, i64 -112
  store double %14, ptr %31, align 8
  %32 = mul i64 %20, 56
  %33 = getelementptr i8, ptr %15, i64 %32
  %34 = getelementptr i8, ptr %33, i64 -56
  store double %14, ptr %34, align 8
  %35 = mul i64 %20, 56
  %36 = getelementptr i8, ptr %15, i64 %35
  store double %14, ptr %36, align 8
  %37 = mul i64 %20, 56
  %38 = getelementptr i8, ptr %15, i64 %37
  %39 = getelementptr i8, ptr %38, i64 56
  store double %14, ptr %39, align 8
  %40 = mul i64 %20, 56
  %41 = getelementptr i8, ptr %15, i64 %40
  %42 = getelementptr i8, ptr %41, i64 112
  store double %14, ptr %42, align 8
  %43 = add nsw i64 %20, 8
  %exitcond.not.7 = icmp eq i64 %43, %3
  br i1 %exitcond.not.7, label %._crit_edge, label %.lr.ph.new

._crit_edge:                                      ; preds = %.prol.loopexit, %.lr.ph.new, %10
  %44 = add nsw i64 %11, 1
  %exitcond6.not = icmp eq i64 %44, %1
  br i1 %exitcond6.not, label %._crit_edge5, label %10

._crit_edge5:                                     ; preds = %._crit_edge, %4
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(write, argmem: none, inaccessiblemem: none)
define void @equation_27(i64 %0, i64 %1) local_unnamed_addr #2 {
  %3 = icmp slt i64 %0, %1
  br i1 %3, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %2
  %4 = sub i64 %1, %0
  %xtraiter = and i64 %4, 7
  %lcmp.mod.not = icmp eq i64 %xtraiter, 0
  br i1 %lcmp.mod.not, label %.lr.ph.prol.loopexit, label %.lr.ph.prol

.lr.ph.prol:                                      ; preds = %.lr.ph.preheader, %.lr.ph.prol
  %5 = phi i64 [ %8, %.lr.ph.prol ], [ %0, %.lr.ph.preheader ]
  %prol.iter = phi i64 [ %prol.iter.next, %.lr.ph.prol ], [ 0, %.lr.ph.preheader ]
  %.idx.prol = mul i64 %5, 56
  %6 = getelementptr i8, ptr @var_3, i64 %.idx.prol
  %7 = getelementptr i8, ptr %6, i64 -56
  store double 4.931500e+02, ptr %7, align 8
  %8 = add nsw i64 %5, 1
  %prol.iter.next = add i64 %prol.iter, 1
  %prol.iter.cmp.not = icmp eq i64 %prol.iter.next, %xtraiter
  br i1 %prol.iter.cmp.not, label %.lr.ph.prol.loopexit, label %.lr.ph.prol, !llvm.loop !35

.lr.ph.prol.loopexit:                             ; preds = %.lr.ph.prol, %.lr.ph.preheader
  %.unr = phi i64 [ %0, %.lr.ph.preheader ], [ %8, %.lr.ph.prol ]
  %9 = sub i64 %0, %1
  %10 = icmp ugt i64 %9, -8
  br i1 %10, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.prol.loopexit, %.lr.ph
  %11 = phi i64 [ %34, %.lr.ph ], [ %.unr, %.lr.ph.prol.loopexit ]
  %.idx = mul i64 %11, 56
  %12 = getelementptr i8, ptr @var_3, i64 %.idx
  %13 = getelementptr i8, ptr %12, i64 -56
  store double 4.931500e+02, ptr %13, align 8
  %14 = mul i64 %11, 56
  %15 = getelementptr i8, ptr @var_3, i64 %14
  store double 4.931500e+02, ptr %15, align 8
  %16 = mul i64 %11, 56
  %17 = getelementptr i8, ptr @var_3, i64 %16
  %18 = getelementptr i8, ptr %17, i64 56
  store double 4.931500e+02, ptr %18, align 8
  %19 = mul i64 %11, 56
  %20 = getelementptr i8, ptr @var_3, i64 %19
  %21 = getelementptr i8, ptr %20, i64 112
  store double 4.931500e+02, ptr %21, align 8
  %22 = mul i64 %11, 56
  %23 = getelementptr i8, ptr @var_3, i64 %22
  %24 = getelementptr i8, ptr %23, i64 168
  store double 4.931500e+02, ptr %24, align 8
  %25 = mul i64 %11, 56
  %26 = getelementptr i8, ptr @var_3, i64 %25
  %27 = getelementptr i8, ptr %26, i64 224
  store double 4.931500e+02, ptr %27, align 8
  %28 = mul i64 %11, 56
  %29 = getelementptr i8, ptr @var_3, i64 %28
  %30 = getelementptr i8, ptr %29, i64 280
  store double 4.931500e+02, ptr %30, align 8
  %31 = mul i64 %11, 56
  %32 = getelementptr i8, ptr @var_3, i64 %31
  %33 = getelementptr i8, ptr %32, i64 336
  store double 4.931500e+02, ptr %33, align 8
  %34 = add nsw i64 %11, 8
  %exitcond.not.7 = icmp eq i64 %34, %1
  br i1 %exitcond.not.7, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph.prol.loopexit, %.lr.ph, %2
  ret void
}

define void @equation_28(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr {
  %7 = icmp slt i64 %0, %1
  br i1 %7, label %.preheader3.lr.ph, label %._crit_edge5

.preheader3.lr.ph:                                ; preds = %6
  %8 = icmp slt i64 %2, %3
  %9 = icmp slt i64 %4, %5
  br label %.preheader3

.preheader3:                                      ; preds = %._crit_edge4, %.preheader3.lr.ph
  %10 = phi i64 [ %0, %.preheader3.lr.ph ], [ %68, %._crit_edge4 ]
  br i1 %8, label %.preheader.lr.ph, label %._crit_edge4

.preheader.lr.ph:                                 ; preds = %.preheader3
  %11 = mul i64 %10, 28
  %12 = add i64 %11, -36
  br label %.preheader

.preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
  %13 = phi i64 [ %2, %.preheader.lr.ph ], [ %67, %._crit_edge ]
  br i1 %9, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %.preheader
  %14 = mul i64 %13, 7
  %15 = add i64 %12, %14
  br label %thread-pre-split.i

thread-pre-split.i:                               ; preds = %thread-pre-split.i, %.lr.ph
  %16 = phi i64 [ %4, %.lr.ph ], [ %66, %thread-pre-split.i ]
  %17 = add i64 %15, %16
  %18 = getelementptr inbounds nuw double, ptr @var_3, i64 %17
  %19 = load double, ptr %18, align 8
  %20 = tail call ptr @llvm.stacksave.p0()
  %21 = fdiv double 5.126400e+02, %19
  %22 = fmul double %21, 4.125750e+00
  %23 = fmul double %21, 3.269730e+00
  %24 = fmul double %21, 3.774920e+00
  %25 = fmul double %21, 2.935740e+00
  %26 = fmul double %21, 8.237470e+00
  %27 = fmul double %21, 1.033120e+01
  %28 = fmul double %21, 5.332600e-01
  %29 = tail call double @_Mexp_f64_f64(double %22)
  call void @llvm.stackrestore.p0(ptr %20)
  %30 = fadd double %29, -1.000000e+00
  %31 = insertelement <2 x double> poison, double %21, i64 0
  %32 = insertelement <2 x double> %31, double %30, i64 1
  %33 = fdiv <2 x double> <double 0x400F34F61672324C, double 0x4046AD4E77FD67A0>, %32
  %shift = shufflevector <2 x double> %33, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop = fadd <2 x double> %33, %shift
  %34 = tail call ptr @llvm.stacksave.p0()
  %35 = tail call double @_Mexp_f64_f64(double %23)
  call void @llvm.stackrestore.p0(ptr %34)
  %36 = tail call ptr @llvm.stacksave.p0()
  %37 = tail call double @_Mexp_f64_f64(double %24)
  call void @llvm.stackrestore.p0(ptr %36)
  %38 = insertelement <2 x double> poison, double %35, i64 0
  %39 = insertelement <2 x double> %38, double %37, i64 1
  %40 = fadd <2 x double> %39, splat (double -1.000000e+00)
  %41 = fdiv <2 x double> <double 0x404DFA8AF7F1A4D9, double 0xC04EE407504DC2A2>, %40
  %foldExtExtBinop16 = fadd <2 x double> %foldExtExtBinop, %41
  %shift18 = shufflevector <2 x double> %41, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop19 = fadd <2 x double> %foldExtExtBinop16, %shift18
  %42 = tail call ptr @llvm.stacksave.p0()
  %43 = tail call double @_Mexp_f64_f64(double %25)
  call void @llvm.stackrestore.p0(ptr %42)
  %44 = tail call ptr @llvm.stacksave.p0()
  %45 = tail call double @_Mexp_f64_f64(double %26)
  call void @llvm.stackrestore.p0(ptr %44)
  %46 = insertelement <2 x double> poison, double %43, i64 0
  %47 = insertelement <2 x double> %46, double %45, i64 1
  %48 = fadd <2 x double> %47, splat (double -1.000000e+00)
  %49 = fdiv <2 x double> <double 0xC0324525CF236784, double 0x4037182B003F022E>, %48
  %foldExtExtBinop21 = fadd <2 x double> %foldExtExtBinop19, %49
  %shift23 = shufflevector <2 x double> %49, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop24 = fadd <2 x double> %foldExtExtBinop21, %shift23
  %50 = tail call ptr @llvm.stacksave.p0()
  %51 = tail call double @_Mexp_f64_f64(double %27)
  call void @llvm.stackrestore.p0(ptr %50)
  %52 = tail call ptr @llvm.stacksave.p0()
  %53 = tail call double @_Mexp_f64_f64(double %28)
  call void @llvm.stackrestore.p0(ptr %52)
  %54 = insertelement <2 x double> poison, double %51, i64 0
  %55 = insertelement <2 x double> %54, double %53, i64 1
  %56 = fadd <2 x double> %55, splat (double -1.000000e+00)
  %57 = fdiv <2 x double> <double 0x4026454310D46C32, double 0x3FE08BF868C4D601>, %56
  %foldExtExtBinop26 = fadd <2 x double> %foldExtExtBinop24, %57
  %shift28 = shufflevector <2 x double> %57, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop29 = fadd <2 x double> %foldExtExtBinop26, %shift28
  %58 = extractelement <2 x double> %foldExtExtBinop29, i64 0
  %59 = fmul double %19, 0x4070380A7B9F18DE
  %60 = fmul double %59, %21
  %61 = fmul double %60, %58
  %62 = fmul double %21, 1.361810e+03
  %63 = fdiv double %62, 5.126400e+02
  %64 = fsub double %61, %63
  %65 = getelementptr double, ptr @var_4, i64 %17
  store double %64, ptr %65, align 8
  %66 = add i64 %16, 1
  %exitcond.not = icmp eq i64 %66, %5
  br i1 %exitcond.not, label %._crit_edge, label %thread-pre-split.i

._crit_edge:                                      ; preds = %thread-pre-split.i, %.preheader
  %67 = add nsw i64 %13, 1
  %exitcond6.not = icmp eq i64 %67, %3
  br i1 %exitcond6.not, label %._crit_edge4, label %.preheader

._crit_edge4:                                     ; preds = %._crit_edge, %.preheader3
  %68 = add nsw i64 %10, 1
  %exitcond7.not = icmp eq i64 %68, %1
  br i1 %exitcond7.not, label %._crit_edge5, label %.preheader3

._crit_edge5:                                     ; preds = %._crit_edge4, %6
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_29(i64 %0, i64 %1) local_unnamed_addr #0 {
  %3 = load double, ptr @var_0, align 8
  %4 = load double, ptr @var, align 8
  %5 = icmp slt i64 %0, %1
  br i1 %5, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %2
  %6 = sub i64 %1, %0
  %min.iters.check = icmp ult i64 %6, 2
  br i1 %min.iters.check, label %.lr.ph.preheader7, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph.preheader
  %n.vec = and i64 %6, -2
  %7 = add i64 %0, %n.vec
  %broadcast.splatinsert = insertelement <2 x double> poison, double %3, i64 0
  %broadcast.splat = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <2 x i32> zeroinitializer
  %broadcast.splatinsert3 = insertelement <2 x double> poison, double %4, i64 0
  %broadcast.splat4 = shufflevector <2 x double> %broadcast.splatinsert3, <2 x double> poison, <2 x i32> zeroinitializer
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %offset.idx = add i64 %0, %index
  %8 = add i64 %offset.idx, -1
  %9 = getelementptr inbounds nuw double, ptr @var_8, i64 %8
  %wide.load = load <2 x double>, ptr %9, align 8
  %10 = getelementptr inbounds nuw double, ptr @var_10, i64 %8
  %wide.load5 = load <2 x double>, ptr %10, align 8
  %11 = mul nuw nsw i64 %8, 224
  %12 = mul nuw nsw i64 %offset.idx, 224
  %13 = getelementptr inbounds nuw i8, ptr @var_4, i64 %11
  %14 = getelementptr inbounds nuw i8, ptr @var_4, i64 %12
  %15 = getelementptr i8, ptr %13, i64 48
  %16 = getelementptr i8, ptr %14, i64 48
  %17 = load double, ptr %15, align 16
  %18 = load double, ptr %16, align 16
  %19 = insertelement <2 x double> poison, double %17, i64 0
  %20 = insertelement <2 x double> %19, double %18, i64 1
  %21 = fadd <2 x double> %20, zeroinitializer
  %22 = getelementptr i8, ptr %13, i64 104
  %23 = getelementptr i8, ptr %14, i64 104
  %24 = load double, ptr %22, align 8
  %25 = load double, ptr %23, align 8
  %26 = insertelement <2 x double> poison, double %24, i64 0
  %27 = insertelement <2 x double> %26, double %25, i64 1
  %28 = fadd <2 x double> %21, %27
  %29 = getelementptr i8, ptr %13, i64 160
  %30 = getelementptr i8, ptr %14, i64 160
  %31 = load double, ptr %29, align 16
  %32 = load double, ptr %30, align 16
  %33 = insertelement <2 x double> poison, double %31, i64 0
  %34 = insertelement <2 x double> %33, double %32, i64 1
  %35 = fadd <2 x double> %28, %34
  %36 = getelementptr i8, ptr %13, i64 216
  %37 = getelementptr i8, ptr %14, i64 216
  %38 = load double, ptr %36, align 8
  %39 = load double, ptr %37, align 8
  %40 = insertelement <2 x double> poison, double %38, i64 0
  %41 = insertelement <2 x double> %40, double %39, i64 1
  %42 = fadd <2 x double> %35, %41
  %43 = fmul <2 x double> %wide.load, splat (double 0x3F6B4E81B4E81B4F)
  %44 = fmul <2 x double> %43, %wide.load5
  %45 = fmul <2 x double> %broadcast.splat, %42
  %46 = getelementptr inbounds nuw double, ptr @var_5, i64 %8
  %wide.load6 = load <2 x double>, ptr %46, align 8
  %47 = fmul <2 x double> %broadcast.splat4, %wide.load6
  %48 = fsub <2 x double> %45, %47
  %49 = fdiv <2 x double> %48, %44
  %50 = getelementptr double, ptr @var_13, i64 %8
  store <2 x double> %49, ptr %50, align 8
  %index.next = add nuw i64 %index, 2
  %51 = icmp eq i64 %index.next, %n.vec
  br i1 %51, label %middle.block, label %vector.body, !llvm.loop !36

middle.block:                                     ; preds = %vector.body
  %cmp.n = icmp eq i64 %6, %n.vec
  br i1 %cmp.n, label %._crit_edge, label %.lr.ph.preheader7

.lr.ph.preheader7:                                ; preds = %.lr.ph.preheader, %middle.block
  %.ph = phi i64 [ %0, %.lr.ph.preheader ], [ %7, %middle.block ]
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader7, %.lr.ph
  %52 = phi i64 [ %80, %.lr.ph ], [ %.ph, %.lr.ph.preheader7 ]
  %53 = add i64 %52, -1
  %54 = getelementptr inbounds nuw double, ptr @var_8, i64 %53
  %55 = load double, ptr %54, align 8
  %56 = getelementptr inbounds nuw double, ptr @var_10, i64 %53
  %57 = load double, ptr %56, align 8
  %.idx = mul nuw nsw i64 %53, 224
  %58 = getelementptr inbounds nuw i8, ptr @var_4, i64 %.idx
  %59 = getelementptr i8, ptr %58, i64 48
  %60 = load double, ptr %59, align 16
  %61 = fadd double %60, 0.000000e+00
  %62 = getelementptr i8, ptr %58, i64 104
  %63 = load double, ptr %62, align 8
  %64 = fadd double %61, %63
  %65 = getelementptr i8, ptr %58, i64 160
  %66 = load double, ptr %65, align 16
  %67 = fadd double %64, %66
  %68 = getelementptr i8, ptr %58, i64 216
  %69 = load double, ptr %68, align 8
  %70 = fadd double %67, %69
  %71 = fmul double %55, 0x3F6B4E81B4E81B4F
  %72 = fmul double %71, %57
  %73 = fmul double %3, %70
  %74 = getelementptr inbounds nuw double, ptr @var_5, i64 %53
  %75 = load double, ptr %74, align 8
  %76 = fmul double %4, %75
  %77 = fsub double %73, %76
  %78 = fdiv double %77, %72
  %79 = getelementptr double, ptr @var_13, i64 %53
  store double %78, ptr %79, align 8
  %80 = add nsw i64 %52, 1
  %exitcond3.not = icmp eq i64 %80, %1
  br i1 %exitcond3.not, label %._crit_edge, label %.lr.ph, !llvm.loop !37

._crit_edge:                                      ; preds = %.lr.ph, %middle.block, %2
  ret void
}

define void @equation_30(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr {
  %7 = load double, ptr @var, align 8
  %8 = tail call ptr @llvm.stacksave.p0()
  %9 = tail call double @_Mpow_f64_f64_f64(double %7, double 8.000000e-01)
  call void @llvm.stackrestore.p0(ptr %8)
  %10 = fmul double %9, 0x40615C71C71C71C7
  %11 = icmp slt i64 %0, %1
  br i1 %11, label %.preheader3.lr.ph, label %._crit_edge5

.preheader3.lr.ph:                                ; preds = %6
  %12 = icmp slt i64 %2, %3
  %13 = icmp slt i64 %4, %5
  %14 = sub i64 %5, %4
  %min.iters.check = icmp ult i64 %14, 4
  %n.vec = and i64 %14, -4
  %15 = add i64 %4, %n.vec
  %broadcast.splatinsert = insertelement <2 x double> poison, double %10, i64 0
  %broadcast.splat = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <2 x i32> zeroinitializer
  %cmp.n = icmp eq i64 %14, %n.vec
  br label %.preheader3

.preheader3:                                      ; preds = %._crit_edge4, %.preheader3.lr.ph
  %16 = phi i64 [ %0, %.preheader3.lr.ph ], [ %44, %._crit_edge4 ]
  br i1 %12, label %.preheader.lr.ph, label %._crit_edge4

.preheader.lr.ph:                                 ; preds = %.preheader3
  %17 = mul i64 %16, 24
  %18 = add i64 %17, -31
  br label %.preheader

.preheader:                                       ; preds = %._crit_edge, %.preheader.lr.ph
  %19 = phi i64 [ %2, %.preheader.lr.ph ], [ %43, %._crit_edge ]
  br i1 %13, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %.preheader
  %20 = mul i64 %19, 6
  %21 = add i64 %18, %20
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %invariant.op = add i64 %4, %21
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %.reass = add i64 %index, %invariant.op
  %22 = getelementptr inbounds nuw double, ptr @var_11, i64 %.reass
  %23 = getelementptr inbounds nuw i8, ptr %22, i64 16
  %wide.load = load <2 x double>, ptr %22, align 8
  %wide.load15 = load <2 x double>, ptr %23, align 8
  %24 = getelementptr inbounds nuw double, ptr @var_6, i64 %.reass
  %25 = getelementptr inbounds nuw i8, ptr %24, i64 16
  %wide.load16 = load <2 x double>, ptr %24, align 8
  %wide.load17 = load <2 x double>, ptr %25, align 8
  %26 = fsub <2 x double> %wide.load, %wide.load16
  %27 = fsub <2 x double> %wide.load15, %wide.load17
  %28 = fmul <2 x double> %broadcast.splat, %26
  %29 = fmul <2 x double> %broadcast.splat, %27
  %30 = getelementptr double, ptr @var_2, i64 %.reass
  %31 = getelementptr i8, ptr %30, i64 16
  store <2 x double> %28, ptr %30, align 8
  store <2 x double> %29, ptr %31, align 8
  %index.next = add nuw i64 %index, 4
  %32 = icmp eq i64 %index.next, %n.vec
  br i1 %32, label %middle.block, label %vector.body, !llvm.loop !38

middle.block:                                     ; preds = %vector.body
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %.lr.ph, %middle.block
  %.ph = phi i64 [ %4, %.lr.ph ], [ %15, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %33 = phi i64 [ %42, %scalar.ph ], [ %.ph, %scalar.ph.preheader ]
  %34 = add i64 %21, %33
  %35 = getelementptr inbounds nuw double, ptr @var_11, i64 %34
  %36 = load double, ptr %35, align 8
  %37 = getelementptr inbounds nuw double, ptr @var_6, i64 %34
  %38 = load double, ptr %37, align 8
  %39 = fsub double %36, %38
  %40 = fmul double %10, %39
  %41 = getelementptr double, ptr @var_2, i64 %34
  store double %40, ptr %41, align 8
  %42 = add nsw i64 %33, 1
  %exitcond.not = icmp eq i64 %42, %5
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !39

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %.preheader
  %43 = add nsw i64 %19, 1
  %exitcond6.not = icmp eq i64 %43, %3
  br i1 %exitcond6.not, label %._crit_edge4, label %.preheader

._crit_edge4:                                     ; preds = %._crit_edge, %.preheader3
  %44 = add nsw i64 %16, 1
  %exitcond7.not = icmp eq i64 %44, %1
  br i1 %exitcond7.not, label %._crit_edge5, label %.preheader3

._crit_edge5:                                     ; preds = %._crit_edge4, %6
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_31(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr #0 {
  %7 = load double, ptr @var_0, align 8
  %8 = icmp slt i64 %0, %1
  br i1 %8, label %.lr.ph8, label %._crit_edge9

.lr.ph8:                                          ; preds = %6
  %9 = icmp slt i64 %2, %3
  %10 = icmp slt i64 %4, %5
  %11 = sub i64 %5, %4
  %min.iters.check = icmp ult i64 %11, 2
  %n.vec = and i64 %11, -2
  %12 = add i64 %4, %n.vec
  %broadcast.splatinsert = insertelement <2 x double> poison, double %7, i64 0
  %broadcast.splat = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <2 x i32> zeroinitializer
  %cmp.n = icmp eq i64 %11, %n.vec
  br label %13

13:                                               ; preds = %._crit_edge6, %.lr.ph8
  %14 = phi i64 [ %0, %.lr.ph8 ], [ %61, %._crit_edge6 ]
  br i1 %9, label %.lr.ph5, label %._crit_edge6

.lr.ph5:                                          ; preds = %13
  %15 = add i64 %14, -1
  %16 = mul nuw nsw i64 %15, 24
  %.idx = mul nuw nsw i64 %15, 224
  %17 = getelementptr inbounds nuw i8, ptr @var_4, i64 %.idx
  br label %18

18:                                               ; preds = %._crit_edge, %.lr.ph5
  %19 = phi i64 [ %2, %.lr.ph5 ], [ %60, %._crit_edge ]
  br i1 %10, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %18
  %20 = add i64 %19, -1
  %21 = mul nuw nsw i64 %20, 6
  %22 = add nuw nsw i64 %21, %16
  %.idx3 = mul nuw nsw i64 %20, 56
  %23 = getelementptr inbounds nuw i8, ptr %17, i64 %.idx3
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.body

vector.body:                                      ; preds = %.lr.ph, %vector.body
  %index = phi i64 [ %index.next, %vector.body ], [ 0, %.lr.ph ]
  %offset.idx = add i64 %4, %index
  %24 = add i64 %offset.idx, -1
  %25 = add nuw nsw i64 %22, %24
  %26 = getelementptr inbounds nuw double, ptr @var_7, i64 %25
  %wide.load = load <2 x double>, ptr %26, align 8
  %27 = fmul <2 x double> %wide.load, splat (double 1.375000e-02)
  %28 = getelementptr inbounds nuw double, ptr @var_9, i64 %25
  %wide.load15 = load <2 x double>, ptr %28, align 8
  %29 = fmul <2 x double> %27, %wide.load15
  %30 = getelementptr inbounds nuw double, ptr %23, i64 %24
  %wide.load16 = load <2 x double>, ptr %30, align 8
  %31 = getelementptr inbounds nuw double, ptr %23, i64 %offset.idx
  %wide.load17 = load <2 x double>, ptr %31, align 8
  %32 = fsub <2 x double> %wide.load16, %wide.load17
  %33 = fmul <2 x double> %broadcast.splat, %32
  %34 = getelementptr inbounds nuw double, ptr @var_2, i64 %25
  %wide.load18 = load <2 x double>, ptr %34, align 8
  %35 = fadd <2 x double> %wide.load18, %33
  %36 = fdiv <2 x double> %35, %29
  %37 = getelementptr double, ptr @var_14, i64 %25
  store <2 x double> %36, ptr %37, align 8
  %index.next = add nuw i64 %index, 2
  %38 = icmp eq i64 %index.next, %n.vec
  br i1 %38, label %middle.block, label %vector.body, !llvm.loop !40

middle.block:                                     ; preds = %vector.body
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %.lr.ph, %middle.block
  %.ph = phi i64 [ %4, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %39 = phi i64 [ %59, %scalar.ph ], [ %.ph, %scalar.ph.preheader ]
  %40 = add i64 %39, -1
  %41 = add nuw nsw i64 %22, %40
  %42 = getelementptr inbounds nuw double, ptr @var_7, i64 %41
  %43 = load double, ptr %42, align 8
  %44 = fmul double %43, 1.375000e-02
  %45 = getelementptr inbounds nuw double, ptr @var_9, i64 %41
  %46 = load double, ptr %45, align 8
  %47 = fmul double %44, %46
  %48 = getelementptr inbounds nuw double, ptr %23, i64 %40
  %49 = load double, ptr %48, align 8
  %50 = getelementptr inbounds nuw double, ptr %23, i64 %39
  %51 = load double, ptr %50, align 8
  %52 = fsub double %49, %51
  %53 = fmul double %7, %52
  %54 = getelementptr inbounds nuw double, ptr @var_2, i64 %41
  %55 = load double, ptr %54, align 8
  %56 = fadd double %55, %53
  %57 = fdiv double %56, %47
  %58 = getelementptr double, ptr @var_14, i64 %41
  store double %57, ptr %58, align 8
  %59 = add nsw i64 %39, 1
  %exitcond.not = icmp eq i64 %59, %5
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !41

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %18
  %60 = add nsw i64 %19, 1
  %exitcond10.not = icmp eq i64 %60, %3
  br i1 %exitcond10.not, label %._crit_edge6, label %18

._crit_edge6:                                     ; preds = %._crit_edge, %13
  %61 = add nsw i64 %14, 1
  %exitcond11.not = icmp eq i64 %61, %1
  br i1 %exitcond11.not, label %._crit_edge9, label %13

._crit_edge9:                                     ; preds = %._crit_edge6, %6
  ret void
}

define void @equation_32(i64 %0, i64 %1) local_unnamed_addr {
  %3 = load double, ptr @time, align 8
  %4 = fmul double %3, 0x3FB015BF92172844
  %5 = icmp slt i64 %0, %1
  br i1 %5, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %2, %.lr.ph
  %6 = phi i64 [ %17, %.lr.ph ], [ %0, %2 ]
  %7 = sitofp i64 %6 to double
  %8 = fmul double %7, 0x401921FB54442EEA
  %9 = fmul double %8, 2.500000e-01
  %10 = fadd double %4, %9
  %11 = tail call ptr @llvm.stacksave.p0()
  %12 = tail call double @_Msin_f64_f64(double %10)
  call void @llvm.stackrestore.p0(ptr %11)
  %13 = fadd double %12, 1.000000e+00
  %14 = fmul double %13, 0x40E4585555555555
  %15 = getelementptr double, ptr @var_1, i64 %6
  %16 = getelementptr i8, ptr %15, i64 -8
  store double %14, ptr %16, align 8
  %17 = add i64 %6, 1
  %exitcond.not = icmp eq i64 %17, %1
  br i1 %exitcond.not, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %2
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @equation_33(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) local_unnamed_addr #0 {
  %7 = icmp slt i64 %0, %1
  br i1 %7, label %.preheader.lr.ph, label %._crit_edge5

.preheader.lr.ph:                                 ; preds = %6
  %8 = icmp slt i64 %2, %3
  %9 = icmp slt i64 %4, %5
  %10 = sub i64 %5, %4
  %min.iters.check = icmp ult i64 %10, 2
  %n.vec = and i64 %10, -2
  %11 = add i64 %4, %n.vec
  %cmp.n = icmp eq i64 %10, %n.vec
  br label %.preheader

.preheader:                                       ; preds = %._crit_edge4, %.preheader.lr.ph
  %12 = phi i64 [ %0, %.preheader.lr.ph ], [ %37, %._crit_edge4 ]
  br i1 %8, label %.lr.ph3, label %._crit_edge4

.lr.ph3:                                          ; preds = %.preheader
  %13 = mul i64 %12, 24
  %14 = add i64 %13, -25
  br label %15

15:                                               ; preds = %._crit_edge, %.lr.ph3
  %16 = phi i64 [ %2, %.lr.ph3 ], [ %36, %._crit_edge ]
  %17 = add i64 %16, -1
  %18 = getelementptr inbounds nuw double, ptr @var_1, i64 %17
  %19 = load double, ptr %18, align 8
  %20 = fdiv double %19, 6.000000e+00
  br i1 %9, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %15
  %21 = mul nuw nsw i64 %17, 6
  %22 = add i64 %14, %21
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %broadcast.splatinsert = insertelement <2 x double> poison, double %20, i64 0
  %broadcast.splat = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <2 x i32> zeroinitializer
  %invariant.op = add i64 %4, %22
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %.reass = add i64 %index, %invariant.op
  %23 = getelementptr inbounds nuw double, ptr @var_2, i64 %.reass
  %wide.load = load <2 x double>, ptr %23, align 8
  %24 = fsub <2 x double> %broadcast.splat, %wide.load
  %25 = fdiv <2 x double> %24, splat (double 0x40615C71C71C71C7)
  %26 = getelementptr double, ptr @var_15, i64 %.reass
  store <2 x double> %25, ptr %26, align 8
  %index.next = add nuw i64 %index, 2
  %27 = icmp eq i64 %index.next, %n.vec
  br i1 %27, label %middle.block, label %vector.body, !llvm.loop !42

middle.block:                                     ; preds = %vector.body
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %.lr.ph, %middle.block
  %.ph = phi i64 [ %4, %.lr.ph ], [ %11, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %28 = phi i64 [ %35, %scalar.ph ], [ %.ph, %scalar.ph.preheader ]
  %29 = add i64 %22, %28
  %30 = getelementptr inbounds nuw double, ptr @var_2, i64 %29
  %31 = load double, ptr %30, align 8
  %32 = fsub double %20, %31
  %33 = fdiv double %32, 0x40615C71C71C71C7
  %34 = getelementptr double, ptr @var_15, i64 %29
  store double %33, ptr %34, align 8
  %35 = add nsw i64 %28, 1
  %exitcond.not = icmp eq i64 %35, %5
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !43

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %15
  %36 = add nsw i64 %16, 1
  %exitcond6.not = icmp eq i64 %36, %3
  br i1 %exitcond6.not, label %._crit_edge4, label %15

._crit_edge4:                                     ; preds = %._crit_edge, %.preheader
  %37 = add nsw i64 %12, 1
  %exitcond7.not = icmp eq i64 %37, %1
  br i1 %exitcond7.not, label %._crit_edge5, label %.preheader

._crit_edge5:                                     ; preds = %._crit_edge4, %6
  ret void
}

define void @MethanolHeatExchangers_dynamic() local_unnamed_addr {
.lr.ph.i:
  %0 = load double, ptr @time, align 8
  %1 = fmul double %0, 0x3FCACEE9F37BEDC6
  %2 = tail call double @_Msin_f64_f64(double %1)
  %3 = fmul double %2, 2.000000e-01
  %4 = fadd double %3, 1.000000e+00
  store double %4, ptr @var, align 8
  %5 = load <2 x double>, ptr @var_12, align 16
  %6 = fmul <2 x double> %5, splat (double 0x4070380A7B9F18DE)
  %7 = fdiv <2 x double> splat (double 2.000000e+06), %6
  store <2 x double> %7, ptr @var_8, align 16
  %8 = load double, ptr getelementptr inbounds nuw (i8, ptr @var_12, i64 16), align 16
  %9 = fmul double %8, 0x4070380A7B9F18DE
  %10 = fdiv double 2.000000e+06, %9
  store double %10, ptr getelementptr inbounds nuw (i8, ptr @var_8, i64 16), align 16
  br label %.lr.ph.i1

.lr.ph.i1:                                        ; preds = %.lr.ph.i, %.lr.ph.i1
  %11 = phi i64 [ %61, %.lr.ph.i1 ], [ 1, %.lr.ph.i ]
  %12 = add nsw i64 %11, -1
  %13 = getelementptr inbounds nuw double, ptr @var_12, i64 %12
  %14 = load double, ptr %13, align 8
  %15 = tail call ptr @llvm.stacksave.p0()
  %16 = fdiv double 5.126400e+02, %14
  %17 = fmul double %16, 4.125750e+00
  %18 = fmul double %16, 3.269730e+00
  %19 = fmul double %16, 3.774920e+00
  %20 = fmul double %16, 2.935740e+00
  %21 = fmul double %16, 8.237470e+00
  %22 = fmul double %16, 1.033120e+01
  %23 = fmul double %16, 5.332600e-01
  %24 = tail call double @_Mexp_f64_f64(double %17)
  call void @llvm.stackrestore.p0(ptr %15)
  %25 = fadd double %24, -1.000000e+00
  %26 = insertelement <2 x double> poison, double %16, i64 0
  %27 = insertelement <2 x double> %26, double %25, i64 1
  %28 = fdiv <2 x double> <double 0x400F34F61672324C, double 0x4046AD4E77FD67A0>, %27
  %shift = shufflevector <2 x double> %28, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop = fadd <2 x double> %28, %shift
  %29 = tail call ptr @llvm.stacksave.p0()
  %30 = tail call double @_Mexp_f64_f64(double %18)
  call void @llvm.stackrestore.p0(ptr %29)
  %31 = tail call ptr @llvm.stacksave.p0()
  %32 = tail call double @_Mexp_f64_f64(double %19)
  call void @llvm.stackrestore.p0(ptr %31)
  %33 = insertelement <2 x double> poison, double %30, i64 0
  %34 = insertelement <2 x double> %33, double %32, i64 1
  %35 = fadd <2 x double> %34, splat (double -1.000000e+00)
  %36 = fdiv <2 x double> <double 0x404DFA8AF7F1A4D9, double 0xC04EE407504DC2A2>, %35
  %foldExtExtBinop58 = fadd <2 x double> %foldExtExtBinop, %36
  %shift60 = shufflevector <2 x double> %36, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop61 = fadd <2 x double> %foldExtExtBinop58, %shift60
  %37 = tail call ptr @llvm.stacksave.p0()
  %38 = tail call double @_Mexp_f64_f64(double %20)
  call void @llvm.stackrestore.p0(ptr %37)
  %39 = tail call ptr @llvm.stacksave.p0()
  %40 = tail call double @_Mexp_f64_f64(double %21)
  call void @llvm.stackrestore.p0(ptr %39)
  %41 = insertelement <2 x double> poison, double %38, i64 0
  %42 = insertelement <2 x double> %41, double %40, i64 1
  %43 = fadd <2 x double> %42, splat (double -1.000000e+00)
  %44 = fdiv <2 x double> <double 0xC0324525CF236784, double 0x4037182B003F022E>, %43
  %foldExtExtBinop63 = fadd <2 x double> %foldExtExtBinop61, %44
  %shift65 = shufflevector <2 x double> %44, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop66 = fadd <2 x double> %foldExtExtBinop63, %shift65
  %45 = tail call ptr @llvm.stacksave.p0()
  %46 = tail call double @_Mexp_f64_f64(double %22)
  call void @llvm.stackrestore.p0(ptr %45)
  %47 = tail call ptr @llvm.stacksave.p0()
  %48 = tail call double @_Mexp_f64_f64(double %23)
  call void @llvm.stackrestore.p0(ptr %47)
  %49 = insertelement <2 x double> poison, double %46, i64 0
  %50 = insertelement <2 x double> %49, double %48, i64 1
  %51 = fadd <2 x double> %50, splat (double -1.000000e+00)
  %52 = fdiv <2 x double> <double 0x4026454310D46C32, double 0x3FE08BF868C4D601>, %51
  %foldExtExtBinop68 = fadd <2 x double> %foldExtExtBinop66, %52
  %shift70 = shufflevector <2 x double> %52, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop71 = fadd <2 x double> %foldExtExtBinop68, %shift70
  %53 = extractelement <2 x double> %foldExtExtBinop71, i64 0
  %54 = fmul double %14, 0x4070380A7B9F18DE
  %55 = fmul double %54, %16
  %56 = fmul double %55, %53
  %57 = fmul double %16, 1.361810e+03
  %58 = fdiv double %57, 5.126400e+02
  %59 = fsub double %56, %58
  %60 = getelementptr double, ptr @var_5, i64 %12
  store double %59, ptr %60, align 8
  %61 = add nuw nsw i64 %11, 1
  %exitcond.not.i2 = icmp eq i64 %61, 4
  br i1 %exitcond.not.i2, label %.lr.ph.i3.preheader, label %.lr.ph.i1

.lr.ph.i3.preheader:                              ; preds = %.lr.ph.i1
  %62 = load double, ptr @var_12, align 16
  %63 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %62)
  %64 = fadd double %63, 0xC070380A7B9F18DE
  store double %64, ptr @var_10, align 16
  %65 = load double, ptr getelementptr inbounds nuw (i8, ptr @var_12, i64 8), align 8
  %66 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %65)
  %67 = fadd double %66, 0xC070380A7B9F18DE
  store double %67, ptr getelementptr inbounds nuw (i8, ptr @var_10, i64 8), align 8
  %68 = load double, ptr getelementptr inbounds nuw (i8, ptr @var_12, i64 16), align 16
  %69 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %68)
  %70 = fadd double %69, 0xC070380A7B9F18DE
  store double %70, ptr getelementptr inbounds nuw (i8, ptr @var_10, i64 16), align 16
  %wide.vec = load <12 x double>, ptr @var_6, align 128
  %71 = fmul <12 x double> %wide.vec, splat (double 0x4070380A7B9F18DE)
  %interleaved.vec = fdiv <12 x double> splat (double 2.000000e+06), %71
  store <12 x double> %interleaved.vec, ptr @var_7, align 128
  %wide.vec.1 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 96), align 32
  %72 = fmul <12 x double> %wide.vec.1, splat (double 0x4070380A7B9F18DE)
  %interleaved.vec.1 = fdiv <12 x double> splat (double 2.000000e+06), %72
  store <12 x double> %interleaved.vec.1, ptr getelementptr inbounds nuw (i8, ptr @var_7, i64 96), align 32
  %wide.vec.191 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 192), align 64
  %73 = fmul <12 x double> %wide.vec.191, splat (double 0x4070380A7B9F18DE)
  %interleaved.vec.192 = fdiv <12 x double> splat (double 2.000000e+06), %73
  store <12 x double> %interleaved.vec.192, ptr getelementptr inbounds nuw (i8, ptr @var_7, i64 192), align 64
  %wide.vec.1.1 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 288), align 32
  %74 = fmul <12 x double> %wide.vec.1.1, splat (double 0x4070380A7B9F18DE)
  %interleaved.vec.1.1 = fdiv <12 x double> splat (double 2.000000e+06), %74
  store <12 x double> %interleaved.vec.1.1, ptr getelementptr inbounds nuw (i8, ptr @var_7, i64 288), align 32
  %wide.vec.2 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 384), align 128
  %75 = fmul <12 x double> %wide.vec.2, splat (double 0x4070380A7B9F18DE)
  %interleaved.vec.2 = fdiv <12 x double> splat (double 2.000000e+06), %75
  store <12 x double> %interleaved.vec.2, ptr getelementptr inbounds nuw (i8, ptr @var_7, i64 384), align 128
  %wide.vec.1.2 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 480), align 32
  %76 = fmul <12 x double> %wide.vec.1.2, splat (double 0x4070380A7B9F18DE)
  %interleaved.vec.1.2 = fdiv <12 x double> splat (double 2.000000e+06), %76
  store <12 x double> %interleaved.vec.1.2, ptr getelementptr inbounds nuw (i8, ptr @var_7, i64 480), align 32
  br label %.preheader3.i7

.preheader3.i7:                                   ; preds = %.lr.ph.i3.preheader, %._crit_edge4.i13
  %77 = phi i64 [ %120, %._crit_edge4.i13 ], [ 1, %.lr.ph.i3.preheader ]
  %78 = mul nuw nsw i64 %77, 24
  %79 = add nsw i64 %78, -31
  br label %.preheader.i8

.preheader.i8:                                    ; preds = %.preheader.i8, %.preheader3.i7
  %80 = phi i64 [ 1, %.preheader3.i7 ], [ %119, %.preheader.i8 ]
  %81 = mul nuw nsw i64 %80, 6
  %82 = add nsw i64 %79, %81
  %83 = add nsw i64 %82, 1
  %84 = getelementptr inbounds nuw double, ptr @var_6, i64 %83
  %85 = load double, ptr %84, align 16
  %86 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %85)
  %87 = fadd double %86, 0xC070380A7B9F18DE
  %88 = getelementptr double, ptr @var_9, i64 %83
  store double %87, ptr %88, align 16
  %89 = add nsw i64 %82, 2
  %90 = getelementptr inbounds nuw double, ptr @var_6, i64 %89
  %91 = load double, ptr %90, align 8
  %92 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %91)
  %93 = fadd double %92, 0xC070380A7B9F18DE
  %94 = getelementptr double, ptr @var_9, i64 %89
  store double %93, ptr %94, align 8
  %95 = add nsw i64 %82, 3
  %96 = getelementptr inbounds nuw double, ptr @var_6, i64 %95
  %97 = load double, ptr %96, align 16
  %98 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %97)
  %99 = fadd double %98, 0xC070380A7B9F18DE
  %100 = getelementptr double, ptr @var_9, i64 %95
  store double %99, ptr %100, align 16
  %101 = add nsw i64 %82, 4
  %102 = getelementptr inbounds nuw double, ptr @var_6, i64 %101
  %103 = load double, ptr %102, align 8
  %104 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %103)
  %105 = fadd double %104, 0xC070380A7B9F18DE
  %106 = getelementptr double, ptr @var_9, i64 %101
  store double %105, ptr %106, align 8
  %107 = add nsw i64 %82, 5
  %108 = getelementptr inbounds nuw double, ptr @var_6, i64 %107
  %109 = load double, ptr %108, align 16
  %110 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %109)
  %111 = fadd double %110, 0xC070380A7B9F18DE
  %112 = getelementptr double, ptr @var_9, i64 %107
  store double %111, ptr %112, align 16
  %113 = add nsw i64 %82, 6
  %114 = getelementptr inbounds nuw double, ptr @var_6, i64 %113
  %115 = load double, ptr %114, align 8
  %116 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %115)
  %117 = fadd double %116, 0xC070380A7B9F18DE
  %118 = getelementptr double, ptr @var_9, i64 %113
  store double %117, ptr %118, align 8
  %119 = add nuw nsw i64 %80, 1
  %exitcond6.not.i12 = icmp eq i64 %119, 5
  br i1 %exitcond6.not.i12, label %._crit_edge4.i13, label %.preheader.i8

._crit_edge4.i13:                                 ; preds = %.preheader.i8
  %120 = add nuw nsw i64 %77, 1
  %exitcond7.not.i14 = icmp eq i64 %120, 4
  br i1 %exitcond7.not.i14, label %.preheader4.i.preheader, label %.preheader3.i7

.preheader4.i.preheader:                          ; preds = %._crit_edge4.i13
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 8), ptr noundef nonnull align 128 dereferenceable(48) @var_6, i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 64), ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 48), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 120), ptr noundef nonnull align 32 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 96), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 176), ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 144), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 232), ptr noundef nonnull align 64 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 192), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 288), ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 240), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 344), ptr noundef nonnull align 32 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 288), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 400), ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 336), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 456), ptr noundef nonnull align 128 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 384), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 512), ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 432), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 568), ptr noundef nonnull align 32 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 480), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 624), ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 528), i64 48, i1 false)
  %121 = load double, ptr @var_12, align 16
  store double %121, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 224), align 16
  store double %121, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 280), align 8
  store double %121, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 336), align 16
  store double %121, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 392), align 8
  %122 = load double, ptr getelementptr inbounds nuw (i8, ptr @var_12, i64 8), align 8
  store double %122, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 448), align 16
  store double %122, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 504), align 8
  store double %122, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 560), align 16
  store double %122, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 616), align 8
  store double 4.931500e+02, ptr @var_3, align 16
  store double 4.931500e+02, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 56), align 8
  store double 4.931500e+02, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 112), align 16
  store double 4.931500e+02, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 168), align 8
  %123 = load double, ptr @time, align 8
  %124 = fmul double %123, 0x3FB015BF92172844
  %125 = fadd double %124, 0x3FF921FB54442EEA
  %126 = tail call ptr @llvm.stacksave.p0()
  %127 = tail call double @_Msin_f64_f64(double %125)
  call void @llvm.stackrestore.p0(ptr %126)
  %128 = fadd double %127, 1.000000e+00
  %129 = fmul double %128, 0x40E4585555555555
  store double %129, ptr @var_1, align 16
  %130 = fadd double %124, 0x400921FB54442EEA
  %131 = tail call ptr @llvm.stacksave.p0()
  %132 = tail call double @_Msin_f64_f64(double %130)
  call void @llvm.stackrestore.p0(ptr %131)
  %133 = fadd double %132, 1.000000e+00
  %134 = fmul double %133, 0x40E4585555555555
  store double %134, ptr getelementptr inbounds nuw (i8, ptr @var_1, i64 8), align 8
  %135 = fadd double %124, 0x4012D97C7F332330
  %136 = tail call ptr @llvm.stacksave.p0()
  %137 = tail call double @_Msin_f64_f64(double %135)
  call void @llvm.stackrestore.p0(ptr %136)
  %138 = fadd double %137, 1.000000e+00
  %139 = fmul double %138, 0x40E4585555555555
  store double %139, ptr getelementptr inbounds nuw (i8, ptr @var_1, i64 16), align 16
  %140 = fadd double %124, 0x401921FB54442EEA
  %141 = tail call ptr @llvm.stacksave.p0()
  %142 = tail call double @_Msin_f64_f64(double %140)
  call void @llvm.stackrestore.p0(ptr %141)
  %143 = fadd double %142, 1.000000e+00
  %144 = fmul double %143, 0x40E4585555555555
  store double %144, ptr getelementptr inbounds nuw (i8, ptr @var_1, i64 24), align 8
  %145 = load double, ptr @var, align 8
  %146 = fmul double %145, 2.500000e-01
  store double %146, ptr @var_0, align 8
  %147 = tail call ptr @llvm.stacksave.p0()
  %148 = tail call double @_Mpow_f64_f64_f64(double %145, double 8.000000e-01)
  call void @llvm.stackrestore.p0(ptr %147)
  %149 = fmul double %148, 0x40615C71C71C71C7
  %broadcast.splatinsert = insertelement <2 x double> poison, double %149, i64 0
  %wide.vec40 = load <12 x double>, ptr @var_11, align 128
  %wide.vec47 = load <12 x double>, ptr @var_6, align 128
  %150 = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <12 x i32> zeroinitializer
  %151 = fsub <12 x double> %wide.vec40, %wide.vec47
  %interleaved.vec54 = fmul <12 x double> %150, %151
  store <12 x double> %interleaved.vec54, ptr @var_2, align 128
  %wide.vec40.1 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 96), align 32
  %wide.vec47.1 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 96), align 32
  %152 = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <12 x i32> zeroinitializer
  %153 = fsub <12 x double> %wide.vec40.1, %wide.vec47.1
  %interleaved.vec54.1 = fmul <12 x double> %152, %153
  store <12 x double> %interleaved.vec54.1, ptr getelementptr inbounds nuw (i8, ptr @var_2, i64 96), align 32
  %broadcast.splatinsert.1 = insertelement <2 x double> poison, double %149, i64 0
  %wide.vec40.193 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 192), align 64
  %wide.vec47.194 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 192), align 64
  %154 = shufflevector <2 x double> %broadcast.splatinsert.1, <2 x double> poison, <12 x i32> zeroinitializer
  %155 = fsub <12 x double> %wide.vec40.193, %wide.vec47.194
  %interleaved.vec54.195 = fmul <12 x double> %154, %155
  store <12 x double> %interleaved.vec54.195, ptr getelementptr inbounds nuw (i8, ptr @var_2, i64 192), align 64
  %wide.vec40.1.1 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 288), align 32
  %wide.vec47.1.1 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 288), align 32
  %156 = shufflevector <2 x double> %broadcast.splatinsert.1, <2 x double> poison, <12 x i32> zeroinitializer
  %157 = fsub <12 x double> %wide.vec40.1.1, %wide.vec47.1.1
  %interleaved.vec54.1.1 = fmul <12 x double> %156, %157
  store <12 x double> %interleaved.vec54.1.1, ptr getelementptr inbounds nuw (i8, ptr @var_2, i64 288), align 32
  %broadcast.splatinsert.2 = insertelement <2 x double> poison, double %149, i64 0
  %wide.vec40.2 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 384), align 128
  %wide.vec47.2 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 384), align 128
  %158 = shufflevector <2 x double> %broadcast.splatinsert.2, <2 x double> poison, <12 x i32> zeroinitializer
  %159 = fsub <12 x double> %wide.vec40.2, %wide.vec47.2
  %interleaved.vec54.2 = fmul <12 x double> %158, %159
  store <12 x double> %interleaved.vec54.2, ptr getelementptr inbounds nuw (i8, ptr @var_2, i64 384), align 128
  %wide.vec40.1.2 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 480), align 32
  %wide.vec47.1.2 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 480), align 32
  %160 = shufflevector <2 x double> %broadcast.splatinsert.2, <2 x double> poison, <12 x i32> zeroinitializer
  %161 = fsub <12 x double> %wide.vec40.1.2, %wide.vec47.1.2
  %interleaved.vec54.1.2 = fmul <12 x double> %160, %161
  store <12 x double> %interleaved.vec54.1.2, ptr getelementptr inbounds nuw (i8, ptr @var_2, i64 480), align 32
  br label %.preheader3.i40

.preheader3.i40:                                  ; preds = %.preheader4.i.preheader, %._crit_edge4.i46
  %162 = phi i64 [ %220, %._crit_edge4.i46 ], [ 1, %.preheader4.i.preheader ]
  %163 = mul nuw nsw i64 %162, 28
  %164 = add nsw i64 %163, -36
  br label %.preheader.i41

.preheader.i41:                                   ; preds = %._crit_edge.i44, %.preheader3.i40
  %165 = phi i64 [ 1, %.preheader3.i40 ], [ %219, %._crit_edge.i44 ]
  %166 = mul nuw nsw i64 %165, 7
  %167 = add nsw i64 %164, %166
  br label %thread-pre-split.i10

thread-pre-split.i10:                             ; preds = %thread-pre-split.i10, %.preheader.i41
  %168 = phi i64 [ 1, %.preheader.i41 ], [ %218, %thread-pre-split.i10 ]
  %169 = add nsw i64 %167, %168
  %170 = getelementptr inbounds nuw double, ptr @var_3, i64 %169
  %171 = load double, ptr %170, align 8
  %172 = tail call ptr @llvm.stacksave.p0()
  %173 = fdiv double 5.126400e+02, %171
  %174 = fmul double %173, 4.125750e+00
  %175 = fmul double %173, 3.269730e+00
  %176 = fmul double %173, 3.774920e+00
  %177 = fmul double %173, 2.935740e+00
  %178 = fmul double %173, 8.237470e+00
  %179 = fmul double %173, 1.033120e+01
  %180 = fmul double %173, 5.332600e-01
  %181 = tail call double @_Mexp_f64_f64(double %174)
  call void @llvm.stackrestore.p0(ptr %172)
  %182 = fadd double %181, -1.000000e+00
  %183 = insertelement <2 x double> poison, double %173, i64 0
  %184 = insertelement <2 x double> %183, double %182, i64 1
  %185 = fdiv <2 x double> <double 0x400F34F61672324C, double 0x4046AD4E77FD67A0>, %184
  %shift73 = shufflevector <2 x double> %185, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop74 = fadd <2 x double> %185, %shift73
  %186 = tail call ptr @llvm.stacksave.p0()
  %187 = tail call double @_Mexp_f64_f64(double %175)
  call void @llvm.stackrestore.p0(ptr %186)
  %188 = tail call ptr @llvm.stacksave.p0()
  %189 = tail call double @_Mexp_f64_f64(double %176)
  call void @llvm.stackrestore.p0(ptr %188)
  %190 = insertelement <2 x double> poison, double %187, i64 0
  %191 = insertelement <2 x double> %190, double %189, i64 1
  %192 = fadd <2 x double> %191, splat (double -1.000000e+00)
  %193 = fdiv <2 x double> <double 0x404DFA8AF7F1A4D9, double 0xC04EE407504DC2A2>, %192
  %foldExtExtBinop76 = fadd <2 x double> %foldExtExtBinop74, %193
  %shift78 = shufflevector <2 x double> %193, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop79 = fadd <2 x double> %foldExtExtBinop76, %shift78
  %194 = tail call ptr @llvm.stacksave.p0()
  %195 = tail call double @_Mexp_f64_f64(double %177)
  call void @llvm.stackrestore.p0(ptr %194)
  %196 = tail call ptr @llvm.stacksave.p0()
  %197 = tail call double @_Mexp_f64_f64(double %178)
  call void @llvm.stackrestore.p0(ptr %196)
  %198 = insertelement <2 x double> poison, double %195, i64 0
  %199 = insertelement <2 x double> %198, double %197, i64 1
  %200 = fadd <2 x double> %199, splat (double -1.000000e+00)
  %201 = fdiv <2 x double> <double 0xC0324525CF236784, double 0x4037182B003F022E>, %200
  %foldExtExtBinop81 = fadd <2 x double> %foldExtExtBinop79, %201
  %shift83 = shufflevector <2 x double> %201, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop84 = fadd <2 x double> %foldExtExtBinop81, %shift83
  %202 = tail call ptr @llvm.stacksave.p0()
  %203 = tail call double @_Mexp_f64_f64(double %179)
  call void @llvm.stackrestore.p0(ptr %202)
  %204 = tail call ptr @llvm.stacksave.p0()
  %205 = tail call double @_Mexp_f64_f64(double %180)
  call void @llvm.stackrestore.p0(ptr %204)
  %206 = insertelement <2 x double> poison, double %203, i64 0
  %207 = insertelement <2 x double> %206, double %205, i64 1
  %208 = fadd <2 x double> %207, splat (double -1.000000e+00)
  %209 = fdiv <2 x double> <double 0x4026454310D46C32, double 0x3FE08BF868C4D601>, %208
  %foldExtExtBinop86 = fadd <2 x double> %foldExtExtBinop84, %209
  %shift88 = shufflevector <2 x double> %209, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop89 = fadd <2 x double> %foldExtExtBinop86, %shift88
  %210 = extractelement <2 x double> %foldExtExtBinop89, i64 0
  %211 = fmul double %171, 0x4070380A7B9F18DE
  %212 = fmul double %211, %173
  %213 = fmul double %212, %210
  %214 = fmul double %173, 1.361810e+03
  %215 = fdiv double %214, 5.126400e+02
  %216 = fsub double %213, %215
  %217 = getelementptr double, ptr @var_4, i64 %169
  store double %216, ptr %217, align 8
  %218 = add nuw nsw i64 %168, 1
  %exitcond.not.i43 = icmp eq i64 %218, 8
  br i1 %exitcond.not.i43, label %._crit_edge.i44, label %thread-pre-split.i10

._crit_edge.i44:                                  ; preds = %thread-pre-split.i10
  %219 = add nuw nsw i64 %165, 1
  %exitcond6.not.i45 = icmp eq i64 %219, 5
  br i1 %exitcond6.not.i45, label %._crit_edge4.i46, label %.preheader.i41

._crit_edge4.i46:                                 ; preds = %._crit_edge.i44
  %220 = add nuw nsw i64 %162, 1
  %exitcond7.not.i47 = icmp eq i64 %220, 4
  br i1 %exitcond7.not.i47, label %.preheader.i49.preheader, label %.preheader3.i40

.preheader.i49.preheader:                         ; preds = %._crit_edge4.i46
  %221 = load double, ptr @var_0, align 8
  %222 = load double, ptr @var, align 8
  %223 = insertelement <2 x double> poison, double %221, i64 0
  %224 = shufflevector <2 x double> %223, <2 x double> poison, <2 x i32> zeroinitializer
  br label %.preheader.i49

.preheader.i49:                                   ; preds = %._crit_edge6.i, %.preheader.i49.preheader
  %225 = phi i64 [ %331, %._crit_edge6.i ], [ 1, %.preheader.i49.preheader ]
  %226 = mul nuw nsw i64 %225, 24
  %227 = add nsw i64 %226, -25
  %228 = add nsw i64 %225, -1
  %229 = getelementptr inbounds nuw double, ptr @var_8, i64 %228
  %230 = load double, ptr %229, align 8
  %231 = getelementptr inbounds nuw double, ptr @var_10, i64 %228
  %232 = load double, ptr %231, align 8
  %.idx.i58 = mul nuw nsw i64 %228, 224
  %233 = getelementptr inbounds nuw i8, ptr @var_4, i64 %.idx.i58
  %234 = mul nuw nsw i64 %228, 24
  %invariant.op80 = add nsw i64 %234, -1
  br label %._crit_edge.i65

._crit_edge.i65:                                  ; preds = %._crit_edge.i65, %.preheader.i49
  %235 = phi i64 [ 1, %.preheader.i49 ], [ %329, %._crit_edge.i65 ]
  %236 = phi double [ 0.000000e+00, %.preheader.i49 ], [ %330, %._crit_edge.i65 ]
  %237 = add nsw i64 %235, -1
  %238 = getelementptr inbounds nuw double, ptr @var_1, i64 %237
  %239 = load double, ptr %238, align 8
  %240 = fdiv double %239, 6.000000e+00
  %241 = mul nuw nsw i64 %237, 6
  %242 = add nsw i64 %227, %241
  %.idx3.i = mul nuw nsw i64 %237, 56
  %243 = getelementptr inbounds nuw i8, ptr %233, i64 %.idx3.i
  %.pre = load double, ptr %243, align 8
  %invariant.op.reass = add nsw i64 %invariant.op80, %241
  %244 = add nsw i64 %242, 1
  %245 = getelementptr inbounds nuw double, ptr @var_2, i64 %244
  %246 = getelementptr double, ptr @var_15, i64 %244
  %.reass = add nuw i64 %234, %241
  %247 = getelementptr inbounds nuw double, ptr @var_7, i64 %.reass
  %248 = load double, ptr %247, align 16
  %249 = fmul double %248, 1.375000e-02
  %250 = getelementptr inbounds nuw double, ptr @var_9, i64 %.reass
  %251 = load double, ptr %250, align 16
  %252 = fmul double %249, %251
  %253 = getelementptr inbounds nuw i8, ptr %243, i64 8
  %254 = getelementptr inbounds nuw double, ptr @var_2, i64 %.reass
  %255 = load double, ptr %254, align 16
  %256 = getelementptr double, ptr @var_14, i64 %.reass
  %257 = load <2 x double>, ptr %245, align 16
  %258 = insertelement <2 x double> poison, double %240, i64 0
  %259 = shufflevector <2 x double> %258, <2 x double> poison, <2 x i32> zeroinitializer
  %260 = fsub <2 x double> %259, %257
  %261 = fdiv <2 x double> %260, splat (double 0x40615C71C71C71C7)
  store <2 x double> %261, ptr %246, align 16
  %.reass.1 = add nsw i64 %invariant.op.reass, 2
  %262 = getelementptr inbounds nuw double, ptr @var_7, i64 %.reass.1
  %263 = getelementptr inbounds nuw double, ptr @var_9, i64 %.reass.1
  %264 = getelementptr inbounds nuw i8, ptr %243, i64 16
  %265 = getelementptr inbounds nuw double, ptr @var_2, i64 %.reass.1
  %266 = getelementptr double, ptr @var_14, i64 %.reass.1
  %267 = add nsw i64 %242, 3
  %268 = getelementptr inbounds nuw double, ptr @var_2, i64 %267
  %269 = getelementptr double, ptr @var_15, i64 %267
  %270 = getelementptr inbounds nuw i8, ptr %243, i64 24
  %271 = load <2 x double>, ptr %253, align 8
  %272 = extractelement <2 x double> %271, i64 0
  %273 = fsub double %.pre, %272
  %274 = fmul double %221, %273
  %275 = fadd double %255, %274
  %276 = fdiv double %275, %252
  store double %276, ptr %256, align 16
  %277 = load <2 x double>, ptr %262, align 8
  %278 = fmul <2 x double> %277, splat (double 1.375000e-02)
  %279 = load <2 x double>, ptr %263, align 8
  %280 = fmul <2 x double> %278, %279
  %281 = load <2 x double>, ptr %264, align 8
  %282 = fsub <2 x double> %271, %281
  %283 = fmul <2 x double> %224, %282
  %284 = load <2 x double>, ptr %265, align 8
  %285 = fadd <2 x double> %284, %283
  %286 = fdiv <2 x double> %285, %280
  store <2 x double> %286, ptr %266, align 8
  %287 = load <2 x double>, ptr %268, align 16
  %288 = fsub <2 x double> %259, %287
  %289 = fdiv <2 x double> %288, splat (double 0x40615C71C71C71C7)
  store <2 x double> %289, ptr %269, align 16
  %.reass.3 = add nsw i64 %invariant.op.reass, 4
  %290 = getelementptr inbounds nuw double, ptr @var_7, i64 %.reass.3
  %291 = getelementptr inbounds nuw double, ptr @var_9, i64 %.reass.3
  %292 = getelementptr inbounds nuw i8, ptr %243, i64 32
  %293 = getelementptr inbounds nuw double, ptr @var_2, i64 %.reass.3
  %294 = getelementptr double, ptr @var_14, i64 %.reass.3
  %295 = add nsw i64 %242, 5
  %296 = getelementptr inbounds nuw double, ptr @var_2, i64 %295
  %297 = getelementptr double, ptr @var_15, i64 %295
  %298 = getelementptr inbounds nuw i8, ptr %243, i64 40
  %299 = load <2 x double>, ptr %270, align 8
  %300 = load <2 x double>, ptr %290, align 8
  %301 = fmul <2 x double> %300, splat (double 1.375000e-02)
  %302 = load <2 x double>, ptr %291, align 8
  %303 = fmul <2 x double> %301, %302
  %304 = load double, ptr %298, align 8
  %305 = load <2 x double>, ptr %292, align 8
  %306 = fsub <2 x double> %299, %305
  %307 = fmul <2 x double> %224, %306
  %308 = load <2 x double>, ptr %293, align 8
  %309 = fadd <2 x double> %308, %307
  %310 = fdiv <2 x double> %309, %303
  store <2 x double> %310, ptr %294, align 8
  %311 = load <2 x double>, ptr %296, align 16
  %312 = fsub <2 x double> %259, %311
  %313 = fdiv <2 x double> %312, splat (double 0x40615C71C71C71C7)
  store <2 x double> %313, ptr %297, align 16
  %.reass.5 = add nsw i64 %invariant.op.reass, 6
  %314 = getelementptr inbounds nuw double, ptr @var_7, i64 %.reass.5
  %315 = load double, ptr %314, align 8
  %316 = fmul double %315, 1.375000e-02
  %317 = getelementptr inbounds nuw double, ptr @var_9, i64 %.reass.5
  %318 = load double, ptr %317, align 8
  %319 = fmul double %316, %318
  %320 = getelementptr inbounds nuw i8, ptr %243, i64 48
  %321 = load double, ptr %320, align 8
  %322 = fsub double %304, %321
  %323 = fmul double %221, %322
  %324 = getelementptr inbounds nuw double, ptr @var_2, i64 %.reass.5
  %325 = load double, ptr %324, align 8
  %326 = fadd double %325, %323
  %327 = fdiv double %326, %319
  %328 = getelementptr double, ptr @var_14, i64 %.reass.5
  store double %327, ptr %328, align 8
  %329 = add nuw nsw i64 %235, 1
  %330 = fadd double %236, %321
  %exitcond10.not.i66 = icmp eq i64 %329, 5
  br i1 %exitcond10.not.i66, label %._crit_edge6.i, label %._crit_edge.i65

._crit_edge6.i:                                   ; preds = %._crit_edge.i65
  %331 = add nuw nsw i64 %225, 1
  %332 = fmul double %230, 0x3F6B4E81B4E81B4F
  %333 = fmul double %332, %232
  %334 = fmul double %221, %330
  %335 = getelementptr inbounds nuw double, ptr @var_5, i64 %228
  %336 = load double, ptr %335, align 8
  %337 = fmul double %222, %336
  %338 = fsub double %334, %337
  %339 = fdiv double %338, %333
  %340 = getelementptr double, ptr @var_13, i64 %228
  store double %339, ptr %340, align 8
  %exitcond11.not.i = icmp eq i64 %331, 4
  br i1 %exitcond11.not.i, label %equation_12.exit, label %.preheader.i49

equation_12.exit:                                 ; preds = %._crit_edge6.i
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none)
define void @MethanolHeatExchangers_schedule_state_variables() local_unnamed_addr #0 {
  %1 = load double, ptr @timeStep, align 8
  %broadcast.splatinsert = insertelement <2 x double> poison, double %1, i64 0
  %2 = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <12 x i32> zeroinitializer
  %3 = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <12 x i32> zeroinitializer
  %4 = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <12 x i32> zeroinitializer
  %5 = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <12 x i32> zeroinitializer
  br label %.preheader1.i

.preheader1.i:                                    ; preds = %.preheader1.i, %0
  %6 = phi i64 [ 0, %0 ], [ %21, %.preheader1.i ]
  %7 = mul nuw nsw i64 %6, 24
  %8 = getelementptr inbounds nuw double, ptr @var_6, i64 %7
  %wide.vec = load <12 x double>, ptr %8, align 64
  %9 = getelementptr inbounds nuw double, ptr @var_14, i64 %7
  %wide.vec7 = load <12 x double>, ptr %9, align 16
  %10 = getelementptr inbounds nuw double, ptr @var_11, i64 %7
  %wide.vec14 = load <12 x double>, ptr %10, align 64
  %11 = getelementptr inbounds nuw double, ptr @var_15, i64 %7
  %wide.vec21 = load <12 x double>, ptr %11, align 16
  %12 = fmul <12 x double> %2, %wide.vec7
  %interleaved.vec = fadd <12 x double> %wide.vec, %12
  store <12 x double> %interleaved.vec, ptr %8, align 64
  %13 = fmul <12 x double> %3, %wide.vec21
  %interleaved.vec28 = fadd <12 x double> %wide.vec14, %13
  store <12 x double> %interleaved.vec28, ptr %10, align 64
  %14 = add nuw nsw i64 %7, 12
  %15 = getelementptr inbounds nuw double, ptr @var_6, i64 %14
  %wide.vec.1 = load <12 x double>, ptr %15, align 32
  %16 = getelementptr inbounds nuw double, ptr @var_14, i64 %14
  %wide.vec7.1 = load <12 x double>, ptr %16, align 16
  %17 = getelementptr inbounds nuw double, ptr @var_11, i64 %14
  %wide.vec14.1 = load <12 x double>, ptr %17, align 32
  %18 = getelementptr inbounds nuw double, ptr @var_15, i64 %14
  %wide.vec21.1 = load <12 x double>, ptr %18, align 16
  %19 = fmul <12 x double> %4, %wide.vec7.1
  %interleaved.vec.1 = fadd <12 x double> %wide.vec.1, %19
  store <12 x double> %interleaved.vec.1, ptr %15, align 32
  %20 = fmul <12 x double> %5, %wide.vec21.1
  %interleaved.vec28.1 = fadd <12 x double> %wide.vec14.1, %20
  store <12 x double> %interleaved.vec28.1, ptr %17, align 32
  %21 = add nuw nsw i64 %6, 1
  %22 = getelementptr inbounds nuw double, ptr @var_12, i64 %6
  %23 = load double, ptr %22, align 8
  %24 = getelementptr inbounds nuw double, ptr @var_13, i64 %6
  %25 = load double, ptr %24, align 8
  %26 = fmul double %1, %25
  %27 = fadd double %23, %26
  store double %27, ptr %22, align 8
  %exitcond.not.i8 = icmp eq i64 %21, 3
  br i1 %exitcond.not.i8, label %euler_state_update_T_m.exit, label %.preheader1.i

euler_state_update_T_m.exit:                      ; preds = %.preheader1.i
  ret void
}

define void @MethanolHeatExchangers_ic() local_unnamed_addr {
.preheader2.i:
  store <2 x double> splat (double 4.931500e+02), ptr @var_6, align 128
  store <2 x double> splat (double 4.931500e+02), ptr @var_11, align 128
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 16), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 16), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 32), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 32), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 48), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 48), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 64), align 64
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 64), align 64
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 80), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 80), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 96), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 96), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 112), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 112), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 128), align 128
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 128), align 128
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 144), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 144), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 160), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 160), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 176), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 176), align 16
  store double 4.931500e+02, ptr @var_12, align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 192), align 64
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 192), align 64
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 208), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 208), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 224), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 224), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 240), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 240), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 256), align 128
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 256), align 128
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 272), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 272), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 288), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 288), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 304), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 304), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 320), align 64
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 320), align 64
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 336), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 336), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 352), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 352), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 368), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 368), align 16
  store double 4.931500e+02, ptr getelementptr inbounds nuw (i8, ptr @var_12, i64 8), align 8
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 384), align 128
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 384), align 128
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 400), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 400), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 416), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 416), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 432), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 432), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 448), align 64
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 448), align 64
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 464), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 464), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 480), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 480), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 496), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 496), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 512), align 128
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 512), align 128
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 528), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 528), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 544), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 544), align 32
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 560), align 16
  store <2 x double> splat (double 4.931500e+02), ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 560), align 16
  store double 4.931500e+02, ptr getelementptr inbounds nuw (i8, ptr @var_12, i64 16), align 16
  %0 = load double, ptr @time, align 8
  %1 = fmul double %0, 0x3FCACEE9F37BEDC6
  %2 = tail call double @_Msin_f64_f64(double %1)
  %3 = fmul double %2, 2.000000e-01
  %4 = fadd double %3, 1.000000e+00
  store double %4, ptr @var, align 8
  store double 4.931500e+02, ptr @var_3, align 16
  store double 4.931500e+02, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 56), align 8
  store double 4.931500e+02, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 112), align 16
  store double 4.931500e+02, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 168), align 8
  %5 = load double, ptr @time, align 8
  %6 = fmul double %5, 0x3FB015BF92172844
  %7 = fadd double %6, 0x3FF921FB54442EEA
  %8 = tail call ptr @llvm.stacksave.p0()
  %9 = tail call double @_Msin_f64_f64(double %7)
  call void @llvm.stackrestore.p0(ptr %8)
  %10 = fadd double %9, 1.000000e+00
  %11 = fmul double %10, 0x40E4585555555555
  store double %11, ptr @var_1, align 16
  %12 = fadd double %6, 0x400921FB54442EEA
  %13 = tail call ptr @llvm.stacksave.p0()
  %14 = tail call double @_Msin_f64_f64(double %12)
  call void @llvm.stackrestore.p0(ptr %13)
  %15 = fadd double %14, 1.000000e+00
  %16 = fmul double %15, 0x40E4585555555555
  store double %16, ptr getelementptr inbounds nuw (i8, ptr @var_1, i64 8), align 8
  %17 = fadd double %6, 0x4012D97C7F332330
  %18 = tail call ptr @llvm.stacksave.p0()
  %19 = tail call double @_Msin_f64_f64(double %17)
  call void @llvm.stackrestore.p0(ptr %18)
  %20 = fadd double %19, 1.000000e+00
  %21 = fmul double %20, 0x40E4585555555555
  store double %21, ptr getelementptr inbounds nuw (i8, ptr @var_1, i64 16), align 16
  %22 = fadd double %6, 0x401921FB54442EEA
  %23 = tail call ptr @llvm.stacksave.p0()
  %24 = tail call double @_Msin_f64_f64(double %22)
  call void @llvm.stackrestore.p0(ptr %23)
  %25 = fadd double %24, 1.000000e+00
  %26 = fmul double %25, 0x40E4585555555555
  store double %26, ptr getelementptr inbounds nuw (i8, ptr @var_1, i64 24), align 8
  %wide.vec = load <12 x double>, ptr @var_6, align 128
  %27 = fmul <12 x double> %wide.vec, splat (double 0x4070380A7B9F18DE)
  %interleaved.vec = fdiv <12 x double> splat (double 2.000000e+06), %27
  store <12 x double> %interleaved.vec, ptr @var_7, align 128
  %wide.vec.1 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 96), align 32
  %28 = fmul <12 x double> %wide.vec.1, splat (double 0x4070380A7B9F18DE)
  %interleaved.vec.1 = fdiv <12 x double> splat (double 2.000000e+06), %28
  store <12 x double> %interleaved.vec.1, ptr getelementptr inbounds nuw (i8, ptr @var_7, i64 96), align 32
  %wide.vec.193 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 192), align 64
  %29 = fmul <12 x double> %wide.vec.193, splat (double 0x4070380A7B9F18DE)
  %interleaved.vec.194 = fdiv <12 x double> splat (double 2.000000e+06), %29
  store <12 x double> %interleaved.vec.194, ptr getelementptr inbounds nuw (i8, ptr @var_7, i64 192), align 64
  %wide.vec.1.1 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 288), align 32
  %30 = fmul <12 x double> %wide.vec.1.1, splat (double 0x4070380A7B9F18DE)
  %interleaved.vec.1.1 = fdiv <12 x double> splat (double 2.000000e+06), %30
  store <12 x double> %interleaved.vec.1.1, ptr getelementptr inbounds nuw (i8, ptr @var_7, i64 288), align 32
  %wide.vec.2 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 384), align 128
  %31 = fmul <12 x double> %wide.vec.2, splat (double 0x4070380A7B9F18DE)
  %interleaved.vec.2 = fdiv <12 x double> splat (double 2.000000e+06), %31
  store <12 x double> %interleaved.vec.2, ptr getelementptr inbounds nuw (i8, ptr @var_7, i64 384), align 128
  %wide.vec.1.2 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 480), align 32
  %32 = fmul <12 x double> %wide.vec.1.2, splat (double 0x4070380A7B9F18DE)
  %interleaved.vec.1.2 = fdiv <12 x double> splat (double 2.000000e+06), %32
  store <12 x double> %interleaved.vec.1.2, ptr getelementptr inbounds nuw (i8, ptr @var_7, i64 480), align 32
  br label %.preheader3.i24

.preheader3.i24:                                  ; preds = %.preheader2.i, %._crit_edge4.i30
  %33 = phi i64 [ %76, %._crit_edge4.i30 ], [ 1, %.preheader2.i ]
  %34 = mul nuw nsw i64 %33, 24
  %35 = add nsw i64 %34, -31
  br label %.preheader.i25

.preheader.i25:                                   ; preds = %.preheader.i25, %.preheader3.i24
  %36 = phi i64 [ 1, %.preheader3.i24 ], [ %75, %.preheader.i25 ]
  %37 = mul nuw nsw i64 %36, 6
  %38 = add nsw i64 %35, %37
  %39 = add nsw i64 %38, 1
  %40 = getelementptr inbounds nuw double, ptr @var_6, i64 %39
  %41 = load double, ptr %40, align 16
  %42 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %41)
  %43 = fadd double %42, 0xC070380A7B9F18DE
  %44 = getelementptr double, ptr @var_9, i64 %39
  store double %43, ptr %44, align 16
  %45 = add nsw i64 %38, 2
  %46 = getelementptr inbounds nuw double, ptr @var_6, i64 %45
  %47 = load double, ptr %46, align 8
  %48 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %47)
  %49 = fadd double %48, 0xC070380A7B9F18DE
  %50 = getelementptr double, ptr @var_9, i64 %45
  store double %49, ptr %50, align 8
  %51 = add nsw i64 %38, 3
  %52 = getelementptr inbounds nuw double, ptr @var_6, i64 %51
  %53 = load double, ptr %52, align 16
  %54 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %53)
  %55 = fadd double %54, 0xC070380A7B9F18DE
  %56 = getelementptr double, ptr @var_9, i64 %51
  store double %55, ptr %56, align 16
  %57 = add nsw i64 %38, 4
  %58 = getelementptr inbounds nuw double, ptr @var_6, i64 %57
  %59 = load double, ptr %58, align 8
  %60 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %59)
  %61 = fadd double %60, 0xC070380A7B9F18DE
  %62 = getelementptr double, ptr @var_9, i64 %57
  store double %61, ptr %62, align 8
  %63 = add nsw i64 %38, 5
  %64 = getelementptr inbounds nuw double, ptr @var_6, i64 %63
  %65 = load double, ptr %64, align 16
  %66 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %65)
  %67 = fadd double %66, 0xC070380A7B9F18DE
  %68 = getelementptr double, ptr @var_9, i64 %63
  store double %67, ptr %68, align 16
  %69 = add nsw i64 %38, 6
  %70 = getelementptr inbounds nuw double, ptr @var_6, i64 %69
  %71 = load double, ptr %70, align 8
  %72 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %71)
  %73 = fadd double %72, 0xC070380A7B9F18DE
  %74 = getelementptr double, ptr @var_9, i64 %69
  store double %73, ptr %74, align 8
  %75 = add nuw nsw i64 %36, 1
  %exitcond6.not.i29 = icmp eq i64 %75, 5
  br i1 %exitcond6.not.i29, label %._crit_edge4.i30, label %.preheader.i25

._crit_edge4.i30:                                 ; preds = %.preheader.i25
  %76 = add nuw nsw i64 %33, 1
  %exitcond7.not.i31 = icmp eq i64 %76, 4
  br i1 %exitcond7.not.i31, label %.preheader4.i.preheader, label %.preheader3.i24

.preheader4.i.preheader:                          ; preds = %._crit_edge4.i30
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 8), ptr noundef nonnull align 128 dereferenceable(48) @var_6, i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 64), ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 48), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 120), ptr noundef nonnull align 32 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 96), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 176), ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 144), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 232), ptr noundef nonnull align 64 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 192), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 288), ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 240), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 344), ptr noundef nonnull align 32 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 288), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 400), ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 336), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 456), ptr noundef nonnull align 128 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 384), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 512), ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 432), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 568), ptr noundef nonnull align 32 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 480), i64 48, i1 false)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_3, i64 624), ptr noundef nonnull align 16 dereferenceable(48) getelementptr inbounds nuw (i8, ptr @var_6, i64 528), i64 48, i1 false)
  %77 = load <2 x double>, ptr @var_12, align 16
  %78 = fmul <2 x double> %77, splat (double 0x4070380A7B9F18DE)
  %79 = fdiv <2 x double> splat (double 2.000000e+06), %78
  store <2 x double> %79, ptr @var_8, align 16
  %80 = load double, ptr getelementptr inbounds nuw (i8, ptr @var_12, i64 16), align 16
  %81 = fmul double %80, 0x4070380A7B9F18DE
  %82 = fdiv double 2.000000e+06, %81
  store double %82, ptr getelementptr inbounds nuw (i8, ptr @var_8, i64 16), align 16
  br label %.lr.ph.i39

.lr.ph.i39:                                       ; preds = %.preheader4.i.preheader, %.lr.ph.i39
  %83 = phi i64 [ %133, %.lr.ph.i39 ], [ 1, %.preheader4.i.preheader ]
  %84 = add nsw i64 %83, -1
  %85 = getelementptr inbounds nuw double, ptr @var_12, i64 %84
  %86 = load double, ptr %85, align 8
  %87 = tail call ptr @llvm.stacksave.p0()
  %88 = fdiv double 5.126400e+02, %86
  %89 = fmul double %88, 4.125750e+00
  %90 = fmul double %88, 3.269730e+00
  %91 = fmul double %88, 3.774920e+00
  %92 = fmul double %88, 2.935740e+00
  %93 = fmul double %88, 8.237470e+00
  %94 = fmul double %88, 1.033120e+01
  %95 = fmul double %88, 5.332600e-01
  %96 = tail call double @_Mexp_f64_f64(double %89)
  call void @llvm.stackrestore.p0(ptr %87)
  %97 = fadd double %96, -1.000000e+00
  %98 = insertelement <2 x double> poison, double %88, i64 0
  %99 = insertelement <2 x double> %98, double %97, i64 1
  %100 = fdiv <2 x double> <double 0x400F34F61672324C, double 0x4046AD4E77FD67A0>, %99
  %shift = shufflevector <2 x double> %100, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop = fadd <2 x double> %100, %shift
  %101 = tail call ptr @llvm.stacksave.p0()
  %102 = tail call double @_Mexp_f64_f64(double %90)
  call void @llvm.stackrestore.p0(ptr %101)
  %103 = tail call ptr @llvm.stacksave.p0()
  %104 = tail call double @_Mexp_f64_f64(double %91)
  call void @llvm.stackrestore.p0(ptr %103)
  %105 = insertelement <2 x double> poison, double %102, i64 0
  %106 = insertelement <2 x double> %105, double %104, i64 1
  %107 = fadd <2 x double> %106, splat (double -1.000000e+00)
  %108 = fdiv <2 x double> <double 0x404DFA8AF7F1A4D9, double 0xC04EE407504DC2A2>, %107
  %foldExtExtBinop60 = fadd <2 x double> %foldExtExtBinop, %108
  %shift62 = shufflevector <2 x double> %108, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop63 = fadd <2 x double> %foldExtExtBinop60, %shift62
  %109 = tail call ptr @llvm.stacksave.p0()
  %110 = tail call double @_Mexp_f64_f64(double %92)
  call void @llvm.stackrestore.p0(ptr %109)
  %111 = tail call ptr @llvm.stacksave.p0()
  %112 = tail call double @_Mexp_f64_f64(double %93)
  call void @llvm.stackrestore.p0(ptr %111)
  %113 = insertelement <2 x double> poison, double %110, i64 0
  %114 = insertelement <2 x double> %113, double %112, i64 1
  %115 = fadd <2 x double> %114, splat (double -1.000000e+00)
  %116 = fdiv <2 x double> <double 0xC0324525CF236784, double 0x4037182B003F022E>, %115
  %foldExtExtBinop65 = fadd <2 x double> %foldExtExtBinop63, %116
  %shift67 = shufflevector <2 x double> %116, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop68 = fadd <2 x double> %foldExtExtBinop65, %shift67
  %117 = tail call ptr @llvm.stacksave.p0()
  %118 = tail call double @_Mexp_f64_f64(double %94)
  call void @llvm.stackrestore.p0(ptr %117)
  %119 = tail call ptr @llvm.stacksave.p0()
  %120 = tail call double @_Mexp_f64_f64(double %95)
  call void @llvm.stackrestore.p0(ptr %119)
  %121 = insertelement <2 x double> poison, double %118, i64 0
  %122 = insertelement <2 x double> %121, double %120, i64 1
  %123 = fadd <2 x double> %122, splat (double -1.000000e+00)
  %124 = fdiv <2 x double> <double 0x4026454310D46C32, double 0x3FE08BF868C4D601>, %123
  %foldExtExtBinop70 = fadd <2 x double> %foldExtExtBinop68, %124
  %shift72 = shufflevector <2 x double> %124, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop73 = fadd <2 x double> %foldExtExtBinop70, %shift72
  %125 = extractelement <2 x double> %foldExtExtBinop73, i64 0
  %126 = fmul double %86, 0x4070380A7B9F18DE
  %127 = fmul double %126, %88
  %128 = fmul double %127, %125
  %129 = fmul double %88, 1.361810e+03
  %130 = fdiv double %129, 5.126400e+02
  %131 = fsub double %128, %130
  %132 = getelementptr double, ptr @var_5, i64 %84
  store double %131, ptr %132, align 8
  %133 = add nuw nsw i64 %83, 1
  %exitcond.not.i40 = icmp eq i64 %133, 4
  br i1 %exitcond.not.i40, label %.lr.ph.i42.preheader, label %.lr.ph.i39

.lr.ph.i42.preheader:                             ; preds = %.lr.ph.i39
  %134 = load double, ptr @var_12, align 16
  %135 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %134)
  %136 = fadd double %135, 0xC070380A7B9F18DE
  store double %136, ptr @var_10, align 16
  %137 = load double, ptr getelementptr inbounds nuw (i8, ptr @var_12, i64 8), align 8
  %138 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %137)
  %139 = fadd double %138, 0xC070380A7B9F18DE
  store double %139, ptr getelementptr inbounds nuw (i8, ptr @var_10, i64 8), align 8
  %140 = load double, ptr getelementptr inbounds nuw (i8, ptr @var_12, i64 16), align 16
  %141 = tail call double @_MMethanolHeatExchangersDAE.Models.Methanol.cp_T(double %140)
  %142 = fadd double %141, 0xC070380A7B9F18DE
  store double %142, ptr getelementptr inbounds nuw (i8, ptr @var_10, i64 16), align 16
  %143 = load double, ptr @var_12, align 16
  store double %143, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 224), align 16
  store double %143, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 280), align 8
  store double %143, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 336), align 16
  store double %143, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 392), align 8
  %144 = load double, ptr getelementptr inbounds nuw (i8, ptr @var_12, i64 8), align 8
  store double %144, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 448), align 16
  store double %144, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 504), align 8
  store double %144, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 560), align 16
  store double %144, ptr getelementptr inbounds nuw (i8, ptr @var_3, i64 616), align 8
  %145 = load double, ptr @var, align 8
  %146 = fmul double %145, 2.500000e-01
  store double %146, ptr @var_0, align 8
  %147 = tail call ptr @llvm.stacksave.p0()
  %148 = tail call double @_Mpow_f64_f64_f64(double %145, double 8.000000e-01)
  call void @llvm.stackrestore.p0(ptr %147)
  %149 = fmul double %148, 0x40615C71C71C71C7
  %broadcast.splatinsert = insertelement <2 x double> poison, double %149, i64 0
  %wide.vec42 = load <12 x double>, ptr @var_11, align 128
  %wide.vec49 = load <12 x double>, ptr @var_6, align 128
  %150 = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <12 x i32> zeroinitializer
  %151 = fsub <12 x double> %wide.vec42, %wide.vec49
  %interleaved.vec56 = fmul <12 x double> %150, %151
  store <12 x double> %interleaved.vec56, ptr @var_2, align 128
  %wide.vec42.1 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 96), align 32
  %wide.vec49.1 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 96), align 32
  %152 = shufflevector <2 x double> %broadcast.splatinsert, <2 x double> poison, <12 x i32> zeroinitializer
  %153 = fsub <12 x double> %wide.vec42.1, %wide.vec49.1
  %interleaved.vec56.1 = fmul <12 x double> %152, %153
  store <12 x double> %interleaved.vec56.1, ptr getelementptr inbounds nuw (i8, ptr @var_2, i64 96), align 32
  %broadcast.splatinsert.1 = insertelement <2 x double> poison, double %149, i64 0
  %wide.vec42.195 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 192), align 64
  %wide.vec49.196 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 192), align 64
  %154 = shufflevector <2 x double> %broadcast.splatinsert.1, <2 x double> poison, <12 x i32> zeroinitializer
  %155 = fsub <12 x double> %wide.vec42.195, %wide.vec49.196
  %interleaved.vec56.197 = fmul <12 x double> %154, %155
  store <12 x double> %interleaved.vec56.197, ptr getelementptr inbounds nuw (i8, ptr @var_2, i64 192), align 64
  %wide.vec42.1.1 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 288), align 32
  %wide.vec49.1.1 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 288), align 32
  %156 = shufflevector <2 x double> %broadcast.splatinsert.1, <2 x double> poison, <12 x i32> zeroinitializer
  %157 = fsub <12 x double> %wide.vec42.1.1, %wide.vec49.1.1
  %interleaved.vec56.1.1 = fmul <12 x double> %156, %157
  store <12 x double> %interleaved.vec56.1.1, ptr getelementptr inbounds nuw (i8, ptr @var_2, i64 288), align 32
  %broadcast.splatinsert.2 = insertelement <2 x double> poison, double %149, i64 0
  %wide.vec42.2 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 384), align 128
  %wide.vec49.2 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 384), align 128
  %158 = shufflevector <2 x double> %broadcast.splatinsert.2, <2 x double> poison, <12 x i32> zeroinitializer
  %159 = fsub <12 x double> %wide.vec42.2, %wide.vec49.2
  %interleaved.vec56.2 = fmul <12 x double> %158, %159
  store <12 x double> %interleaved.vec56.2, ptr getelementptr inbounds nuw (i8, ptr @var_2, i64 384), align 128
  %wide.vec42.1.2 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_11, i64 480), align 32
  %wide.vec49.1.2 = load <12 x double>, ptr getelementptr inbounds nuw (i8, ptr @var_6, i64 480), align 32
  %160 = shufflevector <2 x double> %broadcast.splatinsert.2, <2 x double> poison, <12 x i32> zeroinitializer
  %161 = fsub <12 x double> %wide.vec42.1.2, %wide.vec49.1.2
  %interleaved.vec56.1.2 = fmul <12 x double> %160, %161
  store <12 x double> %interleaved.vec56.1.2, ptr getelementptr inbounds nuw (i8, ptr @var_2, i64 480), align 32
  br label %.preheader3.i60

.preheader3.i60:                                  ; preds = %.lr.ph.i42.preheader, %._crit_edge4.i66
  %162 = phi i64 [ %220, %._crit_edge4.i66 ], [ 1, %.lr.ph.i42.preheader ]
  %163 = mul nuw nsw i64 %162, 28
  %164 = add nsw i64 %163, -36
  br label %.preheader.i61

.preheader.i61:                                   ; preds = %._crit_edge.i64, %.preheader3.i60
  %165 = phi i64 [ 1, %.preheader3.i60 ], [ %219, %._crit_edge.i64 ]
  %166 = mul nuw nsw i64 %165, 7
  %167 = add nsw i64 %164, %166
  br label %thread-pre-split.i12

thread-pre-split.i12:                             ; preds = %thread-pre-split.i12, %.preheader.i61
  %168 = phi i64 [ 1, %.preheader.i61 ], [ %218, %thread-pre-split.i12 ]
  %169 = add nsw i64 %167, %168
  %170 = getelementptr inbounds nuw double, ptr @var_3, i64 %169
  %171 = load double, ptr %170, align 8
  %172 = tail call ptr @llvm.stacksave.p0()
  %173 = fdiv double 5.126400e+02, %171
  %174 = fmul double %173, 4.125750e+00
  %175 = fmul double %173, 3.269730e+00
  %176 = fmul double %173, 3.774920e+00
  %177 = fmul double %173, 2.935740e+00
  %178 = fmul double %173, 8.237470e+00
  %179 = fmul double %173, 1.033120e+01
  %180 = fmul double %173, 5.332600e-01
  %181 = tail call double @_Mexp_f64_f64(double %174)
  call void @llvm.stackrestore.p0(ptr %172)
  %182 = fadd double %181, -1.000000e+00
  %183 = insertelement <2 x double> poison, double %173, i64 0
  %184 = insertelement <2 x double> %183, double %182, i64 1
  %185 = fdiv <2 x double> <double 0x400F34F61672324C, double 0x4046AD4E77FD67A0>, %184
  %shift75 = shufflevector <2 x double> %185, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop76 = fadd <2 x double> %185, %shift75
  %186 = tail call ptr @llvm.stacksave.p0()
  %187 = tail call double @_Mexp_f64_f64(double %175)
  call void @llvm.stackrestore.p0(ptr %186)
  %188 = tail call ptr @llvm.stacksave.p0()
  %189 = tail call double @_Mexp_f64_f64(double %176)
  call void @llvm.stackrestore.p0(ptr %188)
  %190 = insertelement <2 x double> poison, double %187, i64 0
  %191 = insertelement <2 x double> %190, double %189, i64 1
  %192 = fadd <2 x double> %191, splat (double -1.000000e+00)
  %193 = fdiv <2 x double> <double 0x404DFA8AF7F1A4D9, double 0xC04EE407504DC2A2>, %192
  %foldExtExtBinop78 = fadd <2 x double> %foldExtExtBinop76, %193
  %shift80 = shufflevector <2 x double> %193, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop81 = fadd <2 x double> %foldExtExtBinop78, %shift80
  %194 = tail call ptr @llvm.stacksave.p0()
  %195 = tail call double @_Mexp_f64_f64(double %177)
  call void @llvm.stackrestore.p0(ptr %194)
  %196 = tail call ptr @llvm.stacksave.p0()
  %197 = tail call double @_Mexp_f64_f64(double %178)
  call void @llvm.stackrestore.p0(ptr %196)
  %198 = insertelement <2 x double> poison, double %195, i64 0
  %199 = insertelement <2 x double> %198, double %197, i64 1
  %200 = fadd <2 x double> %199, splat (double -1.000000e+00)
  %201 = fdiv <2 x double> <double 0xC0324525CF236784, double 0x4037182B003F022E>, %200
  %foldExtExtBinop83 = fadd <2 x double> %foldExtExtBinop81, %201
  %shift85 = shufflevector <2 x double> %201, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop86 = fadd <2 x double> %foldExtExtBinop83, %shift85
  %202 = tail call ptr @llvm.stacksave.p0()
  %203 = tail call double @_Mexp_f64_f64(double %179)
  call void @llvm.stackrestore.p0(ptr %202)
  %204 = tail call ptr @llvm.stacksave.p0()
  %205 = tail call double @_Mexp_f64_f64(double %180)
  call void @llvm.stackrestore.p0(ptr %204)
  %206 = insertelement <2 x double> poison, double %203, i64 0
  %207 = insertelement <2 x double> %206, double %205, i64 1
  %208 = fadd <2 x double> %207, splat (double -1.000000e+00)
  %209 = fdiv <2 x double> <double 0x4026454310D46C32, double 0x3FE08BF868C4D601>, %208
  %foldExtExtBinop88 = fadd <2 x double> %foldExtExtBinop86, %209
  %shift90 = shufflevector <2 x double> %209, <2 x double> poison, <2 x i32> <i32 1, i32 poison>
  %foldExtExtBinop91 = fadd <2 x double> %foldExtExtBinop88, %shift90
  %210 = extractelement <2 x double> %foldExtExtBinop91, i64 0
  %211 = fmul double %171, 0x4070380A7B9F18DE
  %212 = fmul double %211, %173
  %213 = fmul double %212, %210
  %214 = fmul double %173, 1.361810e+03
  %215 = fdiv double %214, 5.126400e+02
  %216 = fsub double %213, %215
  %217 = getelementptr double, ptr @var_4, i64 %169
  store double %216, ptr %217, align 8
  %218 = add nuw nsw i64 %168, 1
  %exitcond.not.i63 = icmp eq i64 %218, 8
  br i1 %exitcond.not.i63, label %._crit_edge.i64, label %thread-pre-split.i12

._crit_edge.i64:                                  ; preds = %thread-pre-split.i12
  %219 = add nuw nsw i64 %165, 1
  %exitcond6.not.i65 = icmp eq i64 %219, 5
  br i1 %exitcond6.not.i65, label %._crit_edge4.i66, label %.preheader.i61

._crit_edge4.i66:                                 ; preds = %._crit_edge.i64
  %220 = add nuw nsw i64 %162, 1
  %exitcond7.not.i67 = icmp eq i64 %220, 4
  br i1 %exitcond7.not.i67, label %.preheader.i69.preheader, label %.preheader3.i60

.preheader.i69.preheader:                         ; preds = %._crit_edge4.i66
  %221 = load double, ptr @var_0, align 8
  %222 = load double, ptr @var, align 8
  %223 = insertelement <2 x double> poison, double %221, i64 0
  %224 = shufflevector <2 x double> %223, <2 x double> poison, <2 x i32> zeroinitializer
  br label %.preheader.i69

.preheader.i69:                                   ; preds = %._crit_edge6.i, %.preheader.i69.preheader
  %225 = phi i64 [ %331, %._crit_edge6.i ], [ 1, %.preheader.i69.preheader ]
  %226 = mul nuw nsw i64 %225, 24
  %227 = add nsw i64 %226, -25
  %228 = add nsw i64 %225, -1
  %229 = getelementptr inbounds nuw double, ptr @var_8, i64 %228
  %230 = load double, ptr %229, align 8
  %231 = getelementptr inbounds nuw double, ptr @var_10, i64 %228
  %232 = load double, ptr %231, align 8
  %.idx.i78 = mul nuw nsw i64 %228, 224
  %233 = getelementptr inbounds nuw i8, ptr @var_4, i64 %.idx.i78
  %234 = mul nuw nsw i64 %228, 24
  %invariant.op104 = add nsw i64 %234, -1
  br label %._crit_edge.i85

._crit_edge.i85:                                  ; preds = %._crit_edge.i85, %.preheader.i69
  %235 = phi i64 [ 1, %.preheader.i69 ], [ %329, %._crit_edge.i85 ]
  %236 = phi double [ 0.000000e+00, %.preheader.i69 ], [ %330, %._crit_edge.i85 ]
  %237 = add nsw i64 %235, -1
  %238 = getelementptr inbounds nuw double, ptr @var_1, i64 %237
  %239 = load double, ptr %238, align 8
  %240 = fdiv double %239, 6.000000e+00
  %241 = mul nuw nsw i64 %237, 6
  %242 = add nsw i64 %227, %241
  %.idx3.i = mul nuw nsw i64 %237, 56
  %243 = getelementptr inbounds nuw i8, ptr %233, i64 %.idx3.i
  %.pre = load double, ptr %243, align 8
  %invariant.op.reass = add nsw i64 %invariant.op104, %241
  %244 = add nsw i64 %242, 1
  %245 = getelementptr inbounds nuw double, ptr @var_2, i64 %244
  %246 = getelementptr double, ptr @var_15, i64 %244
  %.reass = add nuw i64 %234, %241
  %247 = getelementptr inbounds nuw double, ptr @var_7, i64 %.reass
  %248 = load double, ptr %247, align 16
  %249 = fmul double %248, 1.375000e-02
  %250 = getelementptr inbounds nuw double, ptr @var_9, i64 %.reass
  %251 = load double, ptr %250, align 16
  %252 = fmul double %249, %251
  %253 = getelementptr inbounds nuw i8, ptr %243, i64 8
  %254 = getelementptr inbounds nuw double, ptr @var_2, i64 %.reass
  %255 = load double, ptr %254, align 16
  %256 = getelementptr double, ptr @var_14, i64 %.reass
  %257 = load <2 x double>, ptr %245, align 16
  %258 = insertelement <2 x double> poison, double %240, i64 0
  %259 = shufflevector <2 x double> %258, <2 x double> poison, <2 x i32> zeroinitializer
  %260 = fsub <2 x double> %259, %257
  %261 = fdiv <2 x double> %260, splat (double 0x40615C71C71C71C7)
  store <2 x double> %261, ptr %246, align 16
  %.reass.1 = add nsw i64 %invariant.op.reass, 2
  %262 = getelementptr inbounds nuw double, ptr @var_7, i64 %.reass.1
  %263 = getelementptr inbounds nuw double, ptr @var_9, i64 %.reass.1
  %264 = getelementptr inbounds nuw i8, ptr %243, i64 16
  %265 = getelementptr inbounds nuw double, ptr @var_2, i64 %.reass.1
  %266 = getelementptr double, ptr @var_14, i64 %.reass.1
  %267 = add nsw i64 %242, 3
  %268 = getelementptr inbounds nuw double, ptr @var_2, i64 %267
  %269 = getelementptr double, ptr @var_15, i64 %267
  %270 = getelementptr inbounds nuw i8, ptr %243, i64 24
  %271 = load <2 x double>, ptr %253, align 8
  %272 = extractelement <2 x double> %271, i64 0
  %273 = fsub double %.pre, %272
  %274 = fmul double %221, %273
  %275 = fadd double %255, %274
  %276 = fdiv double %275, %252
  store double %276, ptr %256, align 16
  %277 = load <2 x double>, ptr %262, align 8
  %278 = fmul <2 x double> %277, splat (double 1.375000e-02)
  %279 = load <2 x double>, ptr %263, align 8
  %280 = fmul <2 x double> %278, %279
  %281 = load <2 x double>, ptr %264, align 8
  %282 = fsub <2 x double> %271, %281
  %283 = fmul <2 x double> %224, %282
  %284 = load <2 x double>, ptr %265, align 8
  %285 = fadd <2 x double> %284, %283
  %286 = fdiv <2 x double> %285, %280
  store <2 x double> %286, ptr %266, align 8
  %287 = load <2 x double>, ptr %268, align 16
  %288 = fsub <2 x double> %259, %287
  %289 = fdiv <2 x double> %288, splat (double 0x40615C71C71C71C7)
  store <2 x double> %289, ptr %269, align 16
  %.reass.3 = add nsw i64 %invariant.op.reass, 4
  %290 = getelementptr inbounds nuw double, ptr @var_7, i64 %.reass.3
  %291 = getelementptr inbounds nuw double, ptr @var_9, i64 %.reass.3
  %292 = getelementptr inbounds nuw i8, ptr %243, i64 32
  %293 = getelementptr inbounds nuw double, ptr @var_2, i64 %.reass.3
  %294 = getelementptr double, ptr @var_14, i64 %.reass.3
  %295 = add nsw i64 %242, 5
  %296 = getelementptr inbounds nuw double, ptr @var_2, i64 %295
  %297 = getelementptr double, ptr @var_15, i64 %295
  %298 = getelementptr inbounds nuw i8, ptr %243, i64 40
  %299 = load <2 x double>, ptr %270, align 8
  %300 = load <2 x double>, ptr %290, align 8
  %301 = fmul <2 x double> %300, splat (double 1.375000e-02)
  %302 = load <2 x double>, ptr %291, align 8
  %303 = fmul <2 x double> %301, %302
  %304 = load double, ptr %298, align 8
  %305 = load <2 x double>, ptr %292, align 8
  %306 = fsub <2 x double> %299, %305
  %307 = fmul <2 x double> %224, %306
  %308 = load <2 x double>, ptr %293, align 8
  %309 = fadd <2 x double> %308, %307
  %310 = fdiv <2 x double> %309, %303
  store <2 x double> %310, ptr %294, align 8
  %311 = load <2 x double>, ptr %296, align 16
  %312 = fsub <2 x double> %259, %311
  %313 = fdiv <2 x double> %312, splat (double 0x40615C71C71C71C7)
  store <2 x double> %313, ptr %297, align 16
  %.reass.5 = add nsw i64 %invariant.op.reass, 6
  %314 = getelementptr inbounds nuw double, ptr @var_7, i64 %.reass.5
  %315 = load double, ptr %314, align 8
  %316 = fmul double %315, 1.375000e-02
  %317 = getelementptr inbounds nuw double, ptr @var_9, i64 %.reass.5
  %318 = load double, ptr %317, align 8
  %319 = fmul double %316, %318
  %320 = getelementptr inbounds nuw i8, ptr %243, i64 48
  %321 = load double, ptr %320, align 8
  %322 = fsub double %304, %321
  %323 = fmul double %221, %322
  %324 = getelementptr inbounds nuw double, ptr @var_2, i64 %.reass.5
  %325 = load double, ptr %324, align 8
  %326 = fadd double %325, %323
  %327 = fdiv double %326, %319
  %328 = getelementptr double, ptr @var_14, i64 %.reass.5
  store double %327, ptr %328, align 8
  %329 = add nuw nsw i64 %235, 1
  %330 = fadd double %236, %321
  %exitcond10.not.i86 = icmp eq i64 %329, 5
  br i1 %exitcond10.not.i86, label %._crit_edge6.i, label %._crit_edge.i85

._crit_edge6.i:                                   ; preds = %._crit_edge.i85
  %331 = add nuw nsw i64 %225, 1
  %332 = fmul double %230, 0x3F6B4E81B4E81B4F
  %333 = fmul double %332, %232
  %334 = fmul double %221, %330
  %335 = getelementptr inbounds nuw double, ptr @var_5, i64 %228
  %336 = load double, ptr %335, align 8
  %337 = fmul double %222, %336
  %338 = fsub double %334, %337
  %339 = fdiv double %338, %333
  %340 = getelementptr double, ptr @var_13, i64 %228
  store double %339, ptr %340, align 8
  %exitcond11.not.i = icmp eq i64 %331, 4
  br i1 %exitcond11.not.i, label %equation_31.exit, label %.preheader.i69

equation_31.exit:                                 ; preds = %._crit_edge6.i
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull ptr @getModelName() local_unnamed_addr #3 {
  ret ptr @modelName
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i64 @getNumOfVariables() local_unnamed_addr #3 {
  ret i64 17
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef nonnull ptr @getVariableName(i64 %0) local_unnamed_addr #3 {
  %2 = icmp ult i64 %0, 17
  br i1 %2, label %switch.lookup, label %3

switch.lookup:                                    ; preds = %1
  %reltable.shift = shl nuw nsw i64 %0, 2
  %reltable.intrinsic = tail call ptr @llvm.load.relative.i64(ptr nonnull @switch.table.getVariableName.rel, i64 %reltable.shift)
  br label %3

3:                                                ; preds = %switch.lookup, %1
  %4 = phi ptr [ @var_name_unknown, %1 ], [ %reltable.intrinsic, %switch.lookup ]
  ret ptr %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define range(i64 0, 4) i64 @getVariableRank(i64 %0) local_unnamed_addr #3 {
  %switch.tableidx = add i64 %0, -2
  %2 = icmp ult i64 %switch.tableidx, 15
  br i1 %2, label %switch.lookup, label %3

switch.lookup:                                    ; preds = %1
  %switch.gep = getelementptr inbounds nuw i64, ptr @switch.table.getVariableRank, i64 %switch.tableidx
  %switch.load = load i64, ptr %switch.gep, align 8
  br label %3

3:                                                ; preds = %switch.lookup, %1
  %4 = phi i64 [ 0, %1 ], [ %switch.load, %switch.lookup ]
  ret i64 %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i1 @isPrintable(i64 %0) local_unnamed_addr #3 {
  %cond = icmp eq i64 %0, 13
  ret i1 %cond
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define range(i64 0, 2) i64 @getVariableNumOfPrintableRanges(i64 %0) local_unnamed_addr #3 {
  %cond = icmp eq i64 %0, 13
  %spec.select = zext i1 %cond to i64
  ret i64 %spec.select
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define range(i64 -1, 1) i64 @getVariablePrintableRangeBegin(i64 %0, i64 %1, i64 %2) local_unnamed_addr #3 {
  %cond = icmp ne i64 %0, 13
  %cond1 = icmp ne i64 %1, 0
  %or.cond.not = select i1 %cond, i1 true, i1 %cond1
  %cond2 = icmp ne i64 %2, 0
  %narrow = select i1 %or.cond.not, i1 true, i1 %cond2
  %4 = sext i1 %narrow to i64
  ret i64 %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define range(i64 -1, 4) i64 @getVariablePrintableRangeEnd(i64 %0, i64 %1, i64 %2) local_unnamed_addr #3 {
  %cond = icmp eq i64 %0, 13
  %cond1 = icmp eq i64 %1, 0
  %or.cond = select i1 %cond, i1 %cond1, i1 false
  %cond2 = icmp eq i64 %2, 0
  %4 = select i1 %or.cond, i1 %cond2, i1 false
  %5 = select i1 %4, i64 3, i64 -1
  ret i64 %5
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define range(i64 -1, 17) i64 @getDerivative(i64 %0) local_unnamed_addr #3 {
  %switch.tableidx = add i64 %0, -7
  %2 = icmp ult i64 %switch.tableidx, 7
  br i1 %2, label %switch.lookup, label %3

switch.lookup:                                    ; preds = %1
  %switch.gep = getelementptr inbounds nuw i64, ptr @switch.table.getDerivative, i64 %switch.tableidx
  %switch.load = load i64, ptr %switch.gep, align 8
  br label %3

3:                                                ; preds = %switch.lookup, %1
  %4 = phi i64 [ -1, %1 ], [ %switch.load, %switch.lookup ]
  ret i64 %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define double @var_getter_0(ptr readnone captures(none) %0) local_unnamed_addr #4 {
  %2 = load double, ptr @var, align 8
  ret double %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define double @var_getter_1(ptr readnone captures(none) %0) local_unnamed_addr #4 {
  %2 = load double, ptr @var_0, align 8
  ret double %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @var_getter_2(ptr readonly captures(none) %0) local_unnamed_addr #5 {
  %2 = load i64, ptr %0, align 8
  %3 = getelementptr inbounds nuw double, ptr @var_1, i64 %2
  %4 = load double, ptr %3, align 8
  ret double %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @var_getter_3(ptr readonly captures(none) %0) local_unnamed_addr #5 {
  %2 = load i64, ptr %0, align 8
  %3 = getelementptr i8, ptr %0, i64 8
  %4 = load i64, ptr %3, align 8
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load i64, ptr %5, align 8
  %.idx = mul nuw nsw i64 %2, 192
  %7 = getelementptr inbounds nuw i8, ptr @var_2, i64 %.idx
  %.idx1 = mul nuw nsw i64 %4, 48
  %8 = getelementptr inbounds nuw i8, ptr %7, i64 %.idx1
  %9 = getelementptr inbounds nuw double, ptr %8, i64 %6
  %10 = load double, ptr %9, align 8
  ret double %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @var_getter_4(ptr readonly captures(none) %0) local_unnamed_addr #5 {
  %2 = load i64, ptr %0, align 8
  %3 = getelementptr i8, ptr %0, i64 8
  %4 = load i64, ptr %3, align 8
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load i64, ptr %5, align 8
  %.idx = mul nuw nsw i64 %2, 224
  %7 = getelementptr inbounds nuw i8, ptr @var_3, i64 %.idx
  %.idx1 = mul nuw nsw i64 %4, 56
  %8 = getelementptr inbounds nuw i8, ptr %7, i64 %.idx1
  %9 = getelementptr inbounds nuw double, ptr %8, i64 %6
  %10 = load double, ptr %9, align 8
  ret double %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @var_getter_5(ptr readonly captures(none) %0) local_unnamed_addr #5 {
  %2 = load i64, ptr %0, align 8
  %3 = getelementptr i8, ptr %0, i64 8
  %4 = load i64, ptr %3, align 8
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load i64, ptr %5, align 8
  %.idx = mul nuw nsw i64 %2, 224
  %7 = getelementptr inbounds nuw i8, ptr @var_4, i64 %.idx
  %.idx1 = mul nuw nsw i64 %4, 56
  %8 = getelementptr inbounds nuw i8, ptr %7, i64 %.idx1
  %9 = getelementptr inbounds nuw double, ptr %8, i64 %6
  %10 = load double, ptr %9, align 8
  ret double %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @var_getter_6(ptr readonly captures(none) %0) local_unnamed_addr #5 {
  %2 = load i64, ptr %0, align 8
  %3 = getelementptr inbounds nuw double, ptr @var_5, i64 %2
  %4 = load double, ptr %3, align 8
  ret double %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @var_getter_7(ptr readonly captures(none) %0) local_unnamed_addr #5 {
  %2 = load i64, ptr %0, align 8
  %3 = getelementptr i8, ptr %0, i64 8
  %4 = load i64, ptr %3, align 8
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load i64, ptr %5, align 8
  %.idx = mul nuw nsw i64 %2, 192
  %7 = getelementptr inbounds nuw i8, ptr @var_6, i64 %.idx
  %.idx1 = mul nuw nsw i64 %4, 48
  %8 = getelementptr inbounds nuw i8, ptr %7, i64 %.idx1
  %9 = getelementptr inbounds nuw double, ptr %8, i64 %6
  %10 = load double, ptr %9, align 8
  ret double %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @var_getter_8(ptr readonly captures(none) %0) local_unnamed_addr #5 {
  %2 = load i64, ptr %0, align 8
  %3 = getelementptr i8, ptr %0, i64 8
  %4 = load i64, ptr %3, align 8
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load i64, ptr %5, align 8
  %.idx = mul nuw nsw i64 %2, 192
  %7 = getelementptr inbounds nuw i8, ptr @var_7, i64 %.idx
  %.idx1 = mul nuw nsw i64 %4, 48
  %8 = getelementptr inbounds nuw i8, ptr %7, i64 %.idx1
  %9 = getelementptr inbounds nuw double, ptr %8, i64 %6
  %10 = load double, ptr %9, align 8
  ret double %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @var_getter_9(ptr readonly captures(none) %0) local_unnamed_addr #5 {
  %2 = load i64, ptr %0, align 8
  %3 = getelementptr inbounds nuw double, ptr @var_8, i64 %2
  %4 = load double, ptr %3, align 8
  ret double %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @var_getter_10(ptr readonly captures(none) %0) local_unnamed_addr #5 {
  %2 = load i64, ptr %0, align 8
  %3 = getelementptr i8, ptr %0, i64 8
  %4 = load i64, ptr %3, align 8
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load i64, ptr %5, align 8
  %.idx = mul nuw nsw i64 %2, 192
  %7 = getelementptr inbounds nuw i8, ptr @var_9, i64 %.idx
  %.idx1 = mul nuw nsw i64 %4, 48
  %8 = getelementptr inbounds nuw i8, ptr %7, i64 %.idx1
  %9 = getelementptr inbounds nuw double, ptr %8, i64 %6
  %10 = load double, ptr %9, align 8
  ret double %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @var_getter_11(ptr readonly captures(none) %0) local_unnamed_addr #5 {
  %2 = load i64, ptr %0, align 8
  %3 = getelementptr inbounds nuw double, ptr @var_10, i64 %2
  %4 = load double, ptr %3, align 8
  ret double %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @var_getter_12(ptr readonly captures(none) %0) local_unnamed_addr #5 {
  %2 = load i64, ptr %0, align 8
  %3 = getelementptr i8, ptr %0, i64 8
  %4 = load i64, ptr %3, align 8
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load i64, ptr %5, align 8
  %.idx = mul nuw nsw i64 %2, 192
  %7 = getelementptr inbounds nuw i8, ptr @var_11, i64 %.idx
  %.idx1 = mul nuw nsw i64 %4, 48
  %8 = getelementptr inbounds nuw i8, ptr %7, i64 %.idx1
  %9 = getelementptr inbounds nuw double, ptr %8, i64 %6
  %10 = load double, ptr %9, align 8
  ret double %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @var_getter_13(ptr readonly captures(none) %0) local_unnamed_addr #5 {
  %2 = load i64, ptr %0, align 8
  %3 = getelementptr inbounds nuw double, ptr @var_12, i64 %2
  %4 = load double, ptr %3, align 8
  ret double %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @var_getter_14(ptr readonly captures(none) %0) local_unnamed_addr #5 {
  %2 = load i64, ptr %0, align 8
  %3 = getelementptr inbounds nuw double, ptr @var_13, i64 %2
  %4 = load double, ptr %3, align 8
  ret double %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @var_getter_15(ptr readonly captures(none) %0) local_unnamed_addr #5 {
  %2 = load i64, ptr %0, align 8
  %3 = getelementptr i8, ptr %0, i64 8
  %4 = load i64, ptr %3, align 8
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load i64, ptr %5, align 8
  %.idx = mul nuw nsw i64 %2, 192
  %7 = getelementptr inbounds nuw i8, ptr @var_14, i64 %.idx
  %.idx1 = mul nuw nsw i64 %4, 48
  %8 = getelementptr inbounds nuw i8, ptr %7, i64 %.idx1
  %9 = getelementptr inbounds nuw double, ptr %8, i64 %6
  %10 = load double, ptr %9, align 8
  ret double %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @var_getter_16(ptr readonly captures(none) %0) local_unnamed_addr #5 {
  %2 = load i64, ptr %0, align 8
  %3 = getelementptr i8, ptr %0, i64 8
  %4 = load i64, ptr %3, align 8
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load i64, ptr %5, align 8
  %.idx = mul nuw nsw i64 %2, 192
  %7 = getelementptr inbounds nuw i8, ptr @var_15, i64 %.idx
  %.idx1 = mul nuw nsw i64 %4, 48
  %8 = getelementptr inbounds nuw i8, ptr %7, i64 %.idx1
  %9 = getelementptr inbounds nuw double, ptr %8, i64 %6
  %10 = load double, ptr %9, align 8
  ret double %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define double @getVariableValue(i64 %0, ptr readonly captures(none) %1) local_unnamed_addr #5 {
  switch i64 %0, label %121 [
    i64 0, label %3
    i64 1, label %5
    i64 2, label %7
    i64 3, label %11
    i64 4, label %21
    i64 5, label %31
    i64 6, label %41
    i64 7, label %45
    i64 8, label %55
    i64 9, label %65
    i64 10, label %69
    i64 11, label %79
    i64 12, label %83
    i64 13, label %93
    i64 14, label %97
    i64 15, label %101
    i64 16, label %111
  ]

3:                                                ; preds = %2
  %4 = load double, ptr @var, align 8
  br label %121

5:                                                ; preds = %2
  %6 = load double, ptr @var_0, align 8
  br label %121

7:                                                ; preds = %2
  %8 = load i64, ptr %1, align 8
  %9 = getelementptr inbounds nuw double, ptr @var_1, i64 %8
  %10 = load double, ptr %9, align 8
  br label %121

11:                                               ; preds = %2
  %12 = load i64, ptr %1, align 8
  %13 = getelementptr i8, ptr %1, i64 8
  %14 = load i64, ptr %13, align 8
  %15 = getelementptr i8, ptr %1, i64 16
  %16 = load i64, ptr %15, align 8
  %.idx.i = mul nuw nsw i64 %12, 192
  %17 = getelementptr inbounds nuw i8, ptr @var_2, i64 %.idx.i
  %.idx1.i = mul nuw nsw i64 %14, 48
  %18 = getelementptr inbounds nuw i8, ptr %17, i64 %.idx1.i
  %19 = getelementptr inbounds nuw double, ptr %18, i64 %16
  %20 = load double, ptr %19, align 8
  br label %121

21:                                               ; preds = %2
  %22 = load i64, ptr %1, align 8
  %23 = getelementptr i8, ptr %1, i64 8
  %24 = load i64, ptr %23, align 8
  %25 = getelementptr i8, ptr %1, i64 16
  %26 = load i64, ptr %25, align 8
  %.idx.i1 = mul nuw nsw i64 %22, 224
  %27 = getelementptr inbounds nuw i8, ptr @var_3, i64 %.idx.i1
  %.idx1.i2 = mul nuw nsw i64 %24, 56
  %28 = getelementptr inbounds nuw i8, ptr %27, i64 %.idx1.i2
  %29 = getelementptr inbounds nuw double, ptr %28, i64 %26
  %30 = load double, ptr %29, align 8
  br label %121

31:                                               ; preds = %2
  %32 = load i64, ptr %1, align 8
  %33 = getelementptr i8, ptr %1, i64 8
  %34 = load i64, ptr %33, align 8
  %35 = getelementptr i8, ptr %1, i64 16
  %36 = load i64, ptr %35, align 8
  %.idx.i3 = mul nuw nsw i64 %32, 224
  %37 = getelementptr inbounds nuw i8, ptr @var_4, i64 %.idx.i3
  %.idx1.i4 = mul nuw nsw i64 %34, 56
  %38 = getelementptr inbounds nuw i8, ptr %37, i64 %.idx1.i4
  %39 = getelementptr inbounds nuw double, ptr %38, i64 %36
  %40 = load double, ptr %39, align 8
  br label %121

41:                                               ; preds = %2
  %42 = load i64, ptr %1, align 8
  %43 = getelementptr inbounds nuw double, ptr @var_5, i64 %42
  %44 = load double, ptr %43, align 8
  br label %121

45:                                               ; preds = %2
  %46 = load i64, ptr %1, align 8
  %47 = getelementptr i8, ptr %1, i64 8
  %48 = load i64, ptr %47, align 8
  %49 = getelementptr i8, ptr %1, i64 16
  %50 = load i64, ptr %49, align 8
  %.idx.i5 = mul nuw nsw i64 %46, 192
  %51 = getelementptr inbounds nuw i8, ptr @var_6, i64 %.idx.i5
  %.idx1.i6 = mul nuw nsw i64 %48, 48
  %52 = getelementptr inbounds nuw i8, ptr %51, i64 %.idx1.i6
  %53 = getelementptr inbounds nuw double, ptr %52, i64 %50
  %54 = load double, ptr %53, align 8
  br label %121

55:                                               ; preds = %2
  %56 = load i64, ptr %1, align 8
  %57 = getelementptr i8, ptr %1, i64 8
  %58 = load i64, ptr %57, align 8
  %59 = getelementptr i8, ptr %1, i64 16
  %60 = load i64, ptr %59, align 8
  %.idx.i7 = mul nuw nsw i64 %56, 192
  %61 = getelementptr inbounds nuw i8, ptr @var_7, i64 %.idx.i7
  %.idx1.i8 = mul nuw nsw i64 %58, 48
  %62 = getelementptr inbounds nuw i8, ptr %61, i64 %.idx1.i8
  %63 = getelementptr inbounds nuw double, ptr %62, i64 %60
  %64 = load double, ptr %63, align 8
  br label %121

65:                                               ; preds = %2
  %66 = load i64, ptr %1, align 8
  %67 = getelementptr inbounds nuw double, ptr @var_8, i64 %66
  %68 = load double, ptr %67, align 8
  br label %121

69:                                               ; preds = %2
  %70 = load i64, ptr %1, align 8
  %71 = getelementptr i8, ptr %1, i64 8
  %72 = load i64, ptr %71, align 8
  %73 = getelementptr i8, ptr %1, i64 16
  %74 = load i64, ptr %73, align 8
  %.idx.i9 = mul nuw nsw i64 %70, 192
  %75 = getelementptr inbounds nuw i8, ptr @var_9, i64 %.idx.i9
  %.idx1.i10 = mul nuw nsw i64 %72, 48
  %76 = getelementptr inbounds nuw i8, ptr %75, i64 %.idx1.i10
  %77 = getelementptr inbounds nuw double, ptr %76, i64 %74
  %78 = load double, ptr %77, align 8
  br label %121

79:                                               ; preds = %2
  %80 = load i64, ptr %1, align 8
  %81 = getelementptr inbounds nuw double, ptr @var_10, i64 %80
  %82 = load double, ptr %81, align 8
  br label %121

83:                                               ; preds = %2
  %84 = load i64, ptr %1, align 8
  %85 = getelementptr i8, ptr %1, i64 8
  %86 = load i64, ptr %85, align 8
  %87 = getelementptr i8, ptr %1, i64 16
  %88 = load i64, ptr %87, align 8
  %.idx.i11 = mul nuw nsw i64 %84, 192
  %89 = getelementptr inbounds nuw i8, ptr @var_11, i64 %.idx.i11
  %.idx1.i12 = mul nuw nsw i64 %86, 48
  %90 = getelementptr inbounds nuw i8, ptr %89, i64 %.idx1.i12
  %91 = getelementptr inbounds nuw double, ptr %90, i64 %88
  %92 = load double, ptr %91, align 8
  br label %121

93:                                               ; preds = %2
  %94 = load i64, ptr %1, align 8
  %95 = getelementptr inbounds nuw double, ptr @var_12, i64 %94
  %96 = load double, ptr %95, align 8
  br label %121

97:                                               ; preds = %2
  %98 = load i64, ptr %1, align 8
  %99 = getelementptr inbounds nuw double, ptr @var_13, i64 %98
  %100 = load double, ptr %99, align 8
  br label %121

101:                                              ; preds = %2
  %102 = load i64, ptr %1, align 8
  %103 = getelementptr i8, ptr %1, i64 8
  %104 = load i64, ptr %103, align 8
  %105 = getelementptr i8, ptr %1, i64 16
  %106 = load i64, ptr %105, align 8
  %.idx.i13 = mul nuw nsw i64 %102, 192
  %107 = getelementptr inbounds nuw i8, ptr @var_14, i64 %.idx.i13
  %.idx1.i14 = mul nuw nsw i64 %104, 48
  %108 = getelementptr inbounds nuw i8, ptr %107, i64 %.idx1.i14
  %109 = getelementptr inbounds nuw double, ptr %108, i64 %106
  %110 = load double, ptr %109, align 8
  br label %121

111:                                              ; preds = %2
  %112 = load i64, ptr %1, align 8
  %113 = getelementptr i8, ptr %1, i64 8
  %114 = load i64, ptr %113, align 8
  %115 = getelementptr i8, ptr %1, i64 16
  %116 = load i64, ptr %115, align 8
  %.idx.i15 = mul nuw nsw i64 %112, 192
  %117 = getelementptr inbounds nuw i8, ptr @var_15, i64 %.idx.i15
  %.idx1.i16 = mul nuw nsw i64 %114, 48
  %118 = getelementptr inbounds nuw i8, ptr %117, i64 %.idx1.i16
  %119 = getelementptr inbounds nuw double, ptr %118, i64 %116
  %120 = load double, ptr %119, align 8
  br label %121

121:                                              ; preds = %111, %101, %97, %93, %83, %79, %69, %65, %55, %45, %41, %31, %21, %11, %7, %5, %3, %2
  %122 = phi double [ %120, %111 ], [ %110, %101 ], [ %100, %97 ], [ %96, %93 ], [ %92, %83 ], [ %82, %79 ], [ %78, %69 ], [ %68, %65 ], [ %64, %55 ], [ %54, %45 ], [ %44, %41 ], [ %40, %31 ], [ %30, %21 ], [ %20, %11 ], [ %10, %7 ], [ %6, %5 ], [ %4, %3 ], [ 0.000000e+00, %2 ]
  ret double %122
}

define void @updateNonStateVariables() local_unnamed_addr {
  tail call void @MethanolHeatExchangers_dynamic()
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none)
define void @updateStateVariables(double %0) local_unnamed_addr #6 {
  store double %0, ptr @timeStep, align 8
  tail call void @MethanolHeatExchangers_schedule_state_variables()
  ret void
}

define void @solveICModel() local_unnamed_addr {
  tail call void @MethanolHeatExchangers_ic()
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @icModelBegin() local_unnamed_addr #3 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @icModelEnd() local_unnamed_addr #3 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @dynamicModelBegin() local_unnamed_addr #3 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @dynamicModelEnd() local_unnamed_addr #3 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(write, argmem: none, inaccessiblemem: none)
define void @init() local_unnamed_addr #7 {
  store double 0.000000e+00, ptr @var, align 8
  store double 0.000000e+00, ptr @var_0, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(32) @var_1, i8 0, i64 32, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 128 dereferenceable(576) @var_2, i8 0, i64 576, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(672) @var_3, i8 0, i64 672, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(672) @var_4, i8 0, i64 672, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) @var_5, i8 0, i64 24, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 128 dereferenceable(576) @var_6, i8 0, i64 576, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 128 dereferenceable(576) @var_7, i8 0, i64 576, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) @var_8, i8 0, i64 24, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(576) @var_9, i8 0, i64 576, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) @var_10, i8 0, i64 24, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 128 dereferenceable(576) @var_11, i8 0, i64 576, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) @var_12, i8 0, i64 24, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) @var_13, i8 0, i64 24, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(576) @var_14, i8 0, i64 576, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(576) @var_15, i8 0, i64 576, i1 false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @deinit() local_unnamed_addr #3 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define double @getTime() local_unnamed_addr #4 {
  %1 = load double, ptr @time, align 8
  ret double %1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(write, argmem: none, inaccessiblemem: none)
define void @setTime(double %0) local_unnamed_addr #7 {
  store double %0, ptr @time, align 8
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias writeonly captures(none), ptr noalias readonly captures(none), i64, i1 immarg) #8

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #9

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.stackrestore.p0(ptr) #9

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr writeonly captures(none), i8, i64, i1 immarg) #10

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: read)
declare ptr @llvm.load.relative.i64(ptr, i64) #11

attributes #0 = { nofree norecurse nosync nounwind memory(readwrite, argmem: none, inaccessiblemem: none) }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none) }
attributes #2 = { nofree norecurse nosync nounwind memory(write, argmem: none, inaccessiblemem: none) }
attributes #3 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }
attributes #4 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) }
attributes #5 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) }
attributes #6 = { nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) }
attributes #7 = { mustprogress nofree norecurse nosync nounwind willreturn memory(write, argmem: none, inaccessiblemem: none) }
attributes #8 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #9 = { nocallback nofree nosync nounwind willreturn }
attributes #10 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #11 = { nocallback nofree nosync nounwind willreturn memory(argmem: read) }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = distinct !{!1, !2, !3}
!2 = !{!"llvm.loop.isvectorized", i32 1}
!3 = !{!"llvm.loop.unroll.runtime.disable"}
!4 = distinct !{!4, !3, !2}
!5 = distinct !{!5, !2, !3}
!6 = distinct !{!6, !3, !2}
!7 = distinct !{!7, !2, !3}
!8 = distinct !{!8, !3, !2}
!9 = distinct !{!9, !2, !3}
!10 = distinct !{!10, !3, !2}
!11 = distinct !{!11, !2, !3}
!12 = distinct !{!12, !3, !2}
!13 = distinct !{!13, !14}
!14 = !{!"llvm.loop.unroll.disable"}
!15 = distinct !{!15, !14}
!16 = distinct !{!16, !2, !3}
!17 = distinct !{!17, !3, !2}
!18 = distinct !{!18, !2, !3}
!19 = distinct !{!19, !3, !2}
!20 = distinct !{!20, !2, !3}
!21 = distinct !{!21, !3, !2}
!22 = distinct !{!22, !2, !3}
!23 = distinct !{!23, !3, !2}
!24 = distinct !{!24, !2, !3}
!25 = distinct !{!25, !3, !2}
!26 = distinct !{!26, !2, !3}
!27 = distinct !{!27, !3, !2}
!28 = distinct !{!28, !2, !3}
!29 = distinct !{!29, !3, !2}
!30 = distinct !{!30, !2, !3}
!31 = distinct !{!31, !3, !2}
!32 = distinct !{!32, !2, !3}
!33 = distinct !{!33, !3, !2}
!34 = distinct !{!34, !14}
!35 = distinct !{!35, !14}
!36 = distinct !{!36, !2, !3}
!37 = distinct !{!37, !3, !2}
!38 = distinct !{!38, !2, !3}
!39 = distinct !{!39, !3, !2}
!40 = distinct !{!40, !2, !3}
!41 = distinct !{!41, !3, !2}
!42 = distinct !{!42, !2, !3}
!43 = distinct !{!43, !3, !2}
